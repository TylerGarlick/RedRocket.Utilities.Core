<?xml version="1.0"?>
<doc>
  <assembly>
    <name>FlitBit.Core</name>
  </assembly>
  <members>
    <member name="T:FlitBit.Core.AssemblyLocks">
      <summary>
              Utility class for locks used on assemblies.
            </summary>
    </member>
    <member name="M:FlitBit.Core.AssemblyLocks.GetKeyForAssembly(System.Reflection.Assembly)">
      <summary>
              Gets a key for an assembly suitable for representing the assembly
              as a hashtable or dictionary key without pinning the assembly
              into memory.
            </summary>
      <param name="assembly">the assembly</param>
      <returns>a key for an assembly</returns>
      <requires exception="T:System.ArgumentNullException" csharp="assembly != (System.Reflection.Assembly)null" vb="assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">assembly == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.AssemblyLocks.GetLockForAssembly(System.Reflection.Assembly)">
      <summary>
              Gets a lock for an assembly suitable for synchronizing activity
              on the assembly without blocking other activity in the VM.
            </summary>
      <param name="assembly">the assembly</param>
      <returns>an object suitable for locking activity against the assembly</returns>
      <requires exception="T:System.ArgumentNullException" csharp="assembly != (System.Reflection.Assembly)null" vb="assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">assembly == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.Buffers.BigEndianBufferReader">
      <summary>
              Helper class that reads big-endian binary data from a buffer.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.BufferReader">
      <summary>
              IBufferReader's base implementation
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferReader">
      <summary>
              Helper for reading binary data from a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)">
      <summary>
              Reads a boolean from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(bool) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a byte from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(byte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads an array of bytes from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="count">the number of bytes in the array</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)">
      <summary>
              Reads a char from the buffer (two-byte).
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(char) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads an array of characters from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="arrayLength">the number of characters in the array</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 * arrayLength &lt;= buffer.Length - offset" vb="2 * arrayLength &lt;= buffer.Length - offset">2 * arrayLength &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!((sizeof(char) * arrayLength) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)">
      <summary>
              Reads a decimal from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(decimal) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)">
      <summary>
              Reads a double from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(double) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)">
      <summary>
              Reads an encoded string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="byteCount">the number of bytes used by the string</param>
      <param name="coder">an encoding used to interpret the bytes</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="byteCount &lt;= buffer.Length - offset" vb="byteCount &lt;= buffer.Length - offset">byteCount &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">byteCount &gt; buffer.Length - offset</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)">
      <summary>
              Reads a Guid from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(short) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(int) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(long) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})">
      <summary>
              Reads an instance of type T from the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="reflector">reflector for reading type T</param>
      <returns>the instance of type T read from the buffer</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a signed byte from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(sbyte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)">
      <summary>
              Reads a Single from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(float) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)">
      <summary>
              Reads a length-prefixed string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)">
      <summary>
              Reads a length-prefixed string from the buffer using the encoding given.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="coder">an encoding used to interpret the bytes read</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ushort) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(uint) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ulong) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="P:FlitBit.Core.Buffers.IBufferReader.Encoding">
      <summary>
              Gets the encoding used when reading string data.
            </summary>
      <getter>
        <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">an encoding</param>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadBoolean(System.Byte[],System.Int32@)">
      <summary>
              Reads a boolean from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(bool) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a byte array from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a byte array</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(byte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads a byte array from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="count">number of bytes to read</param>
      <returns>a byte array</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadChar(System.Byte[],System.Int32@)">
      <summary>
              Reads a char from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a char value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(char) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>an int16 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(short) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>an Int32 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(int) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>an Int64 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(long) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadDecimal(System.Byte[],System.Int32@)">
      <summary>
              Reads a decimal from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a decimal value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(decimal) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadDouble(System.Byte[],System.Int32@)">
      <summary>
              Reads a double from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a double value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(double) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadSingle(System.Byte[],System.Int32@)">
      <summary>
              Reads a single from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a single value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(float) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadSByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a signed byte from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a signed byte</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(sbyte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads a UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a UInt32 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ushort) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads a UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a UInt32 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(uint) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads a UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a UInt64 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ulong) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadGuid(System.Byte[],System.Int32@)">
      <summary>
              Reads a Guid from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a guid value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)">
      <summary>
              Reads an length-prefixed string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a string value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)">
      <summary>
              Reads an length-prefixed, encoded string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="coder">an encoding to use when decoding the bytes</param>
      <returns>a string value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)">
      <summary>
              Reads an encoded string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="byteCount">number of bytes to interpret as string data</param>
      <param name="coder">an encoding to use when decoding the bytes</param>
      <returns>a string value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="byteCount &lt;= buffer.Length - offset" vb="byteCount &lt;= buffer.Length - offset">byteCount &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">byteCount &gt; buffer.Length - offset</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads an array of characters from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="arrayLength">number of characters to read</param>
      <returns>a char array</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 * arrayLength &lt;= buffer.Length - offset" vb="2 * arrayLength &lt;= buffer.Length - offset">2 * arrayLength &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!((sizeof(char) * arrayLength) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})">
      <summary>
              Reads an instance of type T from the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="reflector">reflector for reading type T</param>
      <returns>the instance of type T read from the buffer</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.Create">
      <summary>
              Creates the default buffer reader.
            </summary>
      <returns>
              a buffer reader matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.Create(System.Text.Encoding)">
      <summary>
              Creates the default buffer reader.
            </summary>
      <param name="enc">the encoding used to interpret strings.</param>
      <returns>
              a buffer reader matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="P:FlitBit.Core.Buffers.BufferReader.Encoding">
      <summary>
              Gets the reader's encoding. This is the encoding used to read string data from the buffer.
            </summary>
      <getter>
        <ensures inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.get_Encoding" inheritedFromTypeName="IBufferReader" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">an encoding</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.LittleEndianBufferReader">
      <summary>
              Implementation of IBufferreader that reads little endian data from a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">an encoding</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.BigEndianBufferWriter">
      <summary>
              Helper class for writing big-endian binary data to a buffer.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.BufferWriter">
      <summary>
              IBufferWriter's base implementation
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferWriter">
      <summary>
              Helper for writing binary data to a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)">
      <summary>
              Fills a buffer.
            </summary>
      <param name="buffer">a buffer</param>
      <param name="offset">offset to begin</param>
      <param name="count">number of bytes to fill</param>
      <param name="value">fill value</param>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
              Writes a boolean value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(bool) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)">
      <summary>
              Writes a byte value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(byte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])">
      <summary>
              Writes a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="value.Length &lt;= buffer.Length - offset" vb="value.Length &lt;= buffer.Length - offset">value.Length &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">value.Length &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)">
      <summary>
              Writes from a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="source">the source array</param>
      <param name="sourceOffset">offset into source where copying begins</param>
      <param name="count">number of bytes to copy from source into buffer</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="sourceOffset &gt;= 0" vb="sourceOffset &gt;= 0">sourceOffset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">sourceOffset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= source.Length - sourceOffset" vb="count &lt;= source.Length - sourceOffset">count &lt;= source.Length - sourceOffset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; value.Length - sourceOffset</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)">
      <summary>
              Writes a char value (two-byte) to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(char) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)">
      <summary>
              Writes a decimal value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(decimal) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)">
      <summary>
              Writes a boolean value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(double) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)">
      <summary>
              Writes a Guid value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)">
      <summary>
              Writes an Int16 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(short) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Writes an Int32 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(int) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)">
      <summary>
              Writes an Int64 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(long) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)">
      <summary>
              Writes a signed byte value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(sbyte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)">
      <summary>
              Writes a float to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(float) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes an UInt16 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ushort) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes an UInt32 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(uint) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes an UInt64 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ulong) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)">
      <summary>
              Writes an instance of type T to the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="reflector">reflector for writing type T</param>
      <param name="value">the instance</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="P:FlitBit.Core.Buffers.IBufferWriter.Encoding">
      <summary>
              Gets the encoding used when writing string data.
            </summary>
      <getter>
        <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)">
      <summary>
              Fills a buffer.
            </summary>
      <param name="buffer">a buffer</param>
      <param name="offset">offset to begin</param>
      <param name="count">number of bytes to fill</param>
      <param name="value">fill value</param>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
              Writes a boolean value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(bool) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Byte)">
      <summary>
              Writes a byte value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(byte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])">
      <summary>
              Writes a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the array</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="value.Length &lt;= buffer.Length - offset" vb="value.Length &lt;= buffer.Length - offset">value.Length &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">value.Length &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)">
      <summary>
              Writes from a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the source array</param>
      <param name="sourceOffset">offset into source where copying begins</param>
      <param name="count">number of bytes to copy from source into buffer</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="sourceOffset &gt;= 0" vb="sourceOffset &gt;= 0">sourceOffset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">sourceOffset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= source.Length - sourceOffset" vb="count &lt;= source.Length - sourceOffset">count &lt;= source.Length - sourceOffset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; value.Length - sourceOffset</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Char)">
      <summary>
              Writes a char value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(char) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Int16)">
      <summary>
              Writes an Int16 to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(short) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Writes an Int32 to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(int) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Int64)">
      <summary>
              Writes an Int64 to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(long) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)">
      <summary>
              Writes a decimal value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(decimal) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Double)">
      <summary>
              Writes a floating point double value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(double) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Single)">
      <summary>
              Writes a floating point single value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(float) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.SByte)">
      <summary>
              Writes a signed byte to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(sbyte) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes a UInt16 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ushort) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes a UInt32 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(uint) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes a UInt64 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(sizeof(ulong) &lt;= buffer.Length - offset)</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Guid)">
      <summary>
              Writes a Guid value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)">
      <summary>
              Writes an instance of type T to the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="reflector">reflector for writing type T</param>
      <param name="value">the instance</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Create">
      <summary>
              Creates the default buffer writer.
            </summary>
      <returns>
              a buffer writer matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Create(System.Text.Encoding)">
      <summary>
              Creates the default buffer writer.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
      <returns>
              a buffer writer matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="P:FlitBit.Core.Buffers.BufferWriter.Encoding">
      <summary>
              Gets the encoding used when writing string data.
            </summary>
      <getter>
        <ensures inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.get_Encoding" inheritedFromTypeName="IBufferWriter" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes an UInt16 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes an UInt32 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes an UInt64 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.LittleEndianBufferWriter">
      <summary>
              Helper class for writing little-endian binary data to a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes an UInt16 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes an UInt32 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes an UInt64 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.Crc16">
      <summary>
              Utility class for generating CRC16 checksums.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc16.ComputeChecksum(System.Byte[])">
      <summary>
              Computes a checksum over an array of bytes.
            </summary>
      <param name="bytes">the bytes</param>
      <returns>the checksum</returns>
      <requires exception="T:System.ArgumentNullException" csharp="bytes != null" vb="bytes &lt;&gt; Nothing">bytes != null</requires>
      <exception cref="T:System.ArgumentNullException">bytes == null</exception>
    </member>
    <member name="T:FlitBit.Core.Buffers.Crc32">
      <summary>
              Utility class for generating CRC16 checksums.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc32.ComputeChecksum(System.Byte[])">
      <summary>
              Computes a checksum over an array of bytes.
            </summary>
      <param name="bytes">the bytes</param>
      <returns>the checksum</returns>
      <requires exception="T:System.ArgumentNullException" csharp="bytes != null" vb="bytes &lt;&gt; Nothing">bytes != null</requires>
      <exception cref="T:System.ArgumentNullException">bytes == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc32.ComputeChecksum(System.Byte[],System.Int32,System.Int32)">
      <summary>
              Computes a checksum over an array of bytes beginning with the first and
              continuing to length.
            </summary>
      <param name="bytes" />
      <param name="first" />
      <param name="length" />
      <returns />
    </member>
    <member name="T:FlitBit.Core.Buffers.InitialCrcValue">
      <summary>
              A few common initial CRC values
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.InitialCrcValue.Zeros">
      <summary>
              All zero.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.InitialCrcValue.NonZeroX1D0F">
      <summary>
              Common initial value of 0x1D0F
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.InitialCrcValue.NonZeroXFfff">
      <summary>
              Common initial value of 0xFFFF
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.Crc16Ccitt">
      <summary>
              Utility class for generating CRC16CITT checksums.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc16Ccitt.#ctor(FlitBit.Core.Buffers.InitialCrcValue)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="initialValue">which initial value the checksum should use</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc16Ccitt.ComputeChecksum(System.Byte[])">
      <summary>
              Computes a checksum over an array of bytes.
            </summary>
      <param name="bytes">the bytes</param>
      <returns>the checksum</returns>
      <requires exception="T:System.ArgumentNullException" csharp="bytes != null" vb="bytes &lt;&gt; Nothing">bytes != null</requires>
      <exception cref="T:System.ArgumentNullException">bytes == null</exception>
    </member>
    <member name="T:FlitBit.Core.Buffers.BitLayout">
      <summary>
              Enums for bit layouts.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.BitLayout.LittleEndian">
      <summary>
              Little endian - least significant byte first
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.BitLayout.BigEndian">
      <summary>
              Big endian - most significant byte first
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferIO">
      <summary>
              Interface for objects that provide their own buffer IO.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferIO.ReadFromBuffer(FlitBit.Core.Buffers.IBufferReader,System.Byte[],System.Int32@)">
      <summary>
              Reads from the buffer.
            </summary>
      <param name="reader">a buffer reader</param>
      <param name="source">the source buffer</param>
      <param name="offset">
              reference to an offset into the buffer where reading
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <returns>the number of bytes consumed during the read</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferIO.WriteToBuffer(FlitBit.Core.Buffers.IBufferWriter,System.Byte[],System.Int32@)">
      <summary>
              Writes to the buffer.
            </summary>
      <param name="writer">a buffer writer</param>
      <param name="target">the target buffer</param>
      <param name="offset">
              reference to an offset into the buffer where writing
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <returns>total number of bytes written</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.CodeContracts.ContractForIBufferReader">
      <summary>
              CodeContracts Class for IBufferReader
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferReflector`1">
      <summary>
              Reflects type T onto a buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReflector`1.ReadFromBuffer(FlitBit.Core.Buffers.IBufferReader,System.Byte[],System.Int32@,`0@)">
      <summary>
              Reads an instance of type T to the buffer.
            </summary>
      <param name="reader">a buffer reader</param>
      <param name="source">the source buffer</param>
      <param name="offset">
              reference to an offset into the buffer where reading
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <param name="target">variable that will hold the instance upon success</param>
      <returns>the number of bytes consumed during the read</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReflector`1.WriteToBuffer(FlitBit.Core.Buffers.IBufferWriter,System.Byte[],System.Int32@,`0)">
      <summary>
              Writes an instance of type T to the buffer.
            </summary>
      <param name="writer">a buffer writer</param>
      <param name="target">the target buffer</param>
      <param name="offset">
              reference to an offset into the buffer where writing
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <param name="source">the instance of type T being written</param>
      <returns>total number of bytes written</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.CodeContracts.ContractForIBufferWriter">
      <summary>
              CodeContracts Class for IBufferWriter
            </summary>
    </member>
    <member name="P:FlitBit.Core.Buffers.CodeContracts.ContractForIBufferWriter.Encoding">
      <summary>
              Gets the encoding used when writing string data.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.Int32SingleUnion">
      <summary>
              Utility struct to convert between Int32 and Single
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Int32SingleUnion.#ctor(System.Int32)">
      <summary>
              Creates an instance initialized with the given integer.
            </summary>
      <param name="i">An Int32 value.</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.Int32SingleUnion.#ctor(System.Single)">
      <summary>
              Creates an instance initialized with the given floating point number.
            </summary>
      <param name="f">A Single value.</param>
    </member>
    <member name="P:FlitBit.Core.Buffers.Int32SingleUnion.AsInt32">
      <summary>
              Returns the value of the instance as an Int32.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Buffers.Int32SingleUnion.AsSingle">
      <summary>
              Returns the value of the instance as a Single.
            </summary>
    </member>
    <member name="T:FlitBit.Core.CleanupScope">
      <summary>
              Utility class for collecting actions and disposable items for cleanup. Actions and
              disposable items, at dispose time, are either disposed (IDisposables)
              or invoked (Actions) in the reverse order in which they are added to the scope.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Disposable">
      <summary>
              Abstract logic for disposable objects.
            </summary>
    </member>
    <member name="T:FlitBit.Core.IInterrogateDisposable">
      <summary>
              Interface for disposable objects that can be interrogated about their disposed state.
            </summary>
    </member>
    <member name="P:FlitBit.Core.IInterrogateDisposable.IsDisposed">
      <summary>
              Indicates whether the disposable has been disposed.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.#ctor(System.Boolean)">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.Finalize">
      <summary>
              Finalizes the instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.Dispose">
      <summary>
              Disposes the instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.PerformDispose(System.Boolean)">
      <summary>
              Performs the dispose logic.
            </summary>
      <param name="disposing">Whether the object is disposing (IDisposable.Dispose method was called).</param>
      <returns>Implementers should return true if the disposal was successful; otherwise false.</returns>
    </member>
    <member name="P:FlitBit.Core.Disposable.CreationStack">
      <summary>
              Exposes the call stack at the time of creation if the subtype indicated that it should be captured.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Disposable.IsDisposed">
      <summary>
              Indicates whether the instance has been disposed.
            </summary>
    </member>
    <member name="T:FlitBit.Core.ICleanupScope">
      <summary>
              Deliniates a cleanup scope.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.IParallelShared">
      <summary>
              Framework interface used to share objects across threads using context-flow.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.IParallelShared.ParallelShare">
      <summary>
              Prepares the instance for sharing across threads.
              This call should be wrapped in a 'using clause' to
              ensure proper cleanup of both the shared and the original.
            </summary>
      <returns>An equivalent instance.</returns>
    </member>
    <member name="M:FlitBit.Core.ICleanupScope.Add``1(``0)">
      <summary>
              Adds a disposable item to the scope. When the scope
              is disposed all added items are guaranteed to also be
              disposed.
            </summary>
      <typeparam name="T" />
      <param name="item" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="(decimal)item != null" vb="((Object)item) &lt;&gt; Nothing">(decimal)item != null</requires>
      <exception cref="T:System.ArgumentNullException">item == null</exception>
      <ensures csharp="(decimal)result != null" vb="((Object)result) &lt;&gt; Nothing">(decimal)result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.ICleanupScope.AddAction(System.Action)">
      <summary>
              Adds an action to be performed upon scope
              completion (on dispose).
            </summary>
      <param name="action" />
      <requires exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor">
      <summary>
              Creates a new scope.
            </summary>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Boolean)">
      <summary>
              Creates a new scope.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Object,System.Boolean)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
      <param name="ownerNotifier">the owner, notifier</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Object)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="ownerNotifier">the owner, notifier</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Boolean,System.IDisposable[])">
      <summary>
              Creates a new scope and adds to it the disposable item given.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
      <param name="items">Items to be disposed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.IDisposable[])">
      <summary>
              Creates a new scope and adds to it the disposable item given.
            </summary>
      <param name="items">Items to be disposed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Boolean,System.Action[])">
      <summary>
              Creates a new scope and adds an action to be performed when the scope is cleaned up.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
      <param name="actions">an array of actions to be performed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Action[])">
      <summary>
              Creates a new scope and adds an action to be performed when the scope is cleaned up.
            </summary>
      <param name="actions">an array of actions to be performed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.ShareScope">
      <summary>
              Shares the scope. Callers must guarantee that there is a matching call to Dispose
              for every call to share. Preferrably by wrapping it in a using clause.
            </summary>
      <returns>the shared scope</returns>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.PerformDispose(System.Boolean)">
      <summary>
              Performs the scope's disposal.
            </summary>
      <param name="disposing">indicates whether the scope is disposing</param>
      <returns>
        <em>true</em> if disposed as a result of the call; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.Add``1(``0)">
      <summary>
              Adds a disposable item to the cleanup scope. Actions and disposable items are collected
              and at cleanup whill be either disposed (IDisposables) or invoked (Actions) in the reverse
              order in which they are added.
            </summary>
      <typeparam name="T">Type of the item being added; ensures IDisposable by inference.</typeparam>
      <param name="item">An item to be disposed when the scope is cleaned up.</param>
      <returns>Returns the item given.</returns>
      <requires inheritedFrom="M:FlitBit.Core.ICleanupScope.Add``1(``0)" inheritedFromTypeName="ICleanupScope" exception="T:System.ArgumentNullException" csharp="(decimal)item != null" vb="((Object)item) &lt;&gt; Nothing">(decimal)item != null</requires>
      <exception cref="T:System.ArgumentNullException">item == null</exception>
      <ensures inheritedFrom="M:FlitBit.Core.ICleanupScope.Add``1(``0)" inheritedFromTypeName="ICleanupScope" csharp="(decimal)result != null" vb="((Object)result) &lt;&gt; Nothing">(decimal)result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.AddAction(System.Action)">
      <summary>
              Adds an action to the cleanup scope. Actions and IDisposables collected in the same queue and
              are either disposed (IDisposables) or invoked (Actions) in the reverse order in which they are
              added.
            </summary>
      <param name="action">An action to be performed when the scope is cleaned up.</param>
      <requires inheritedFrom="M:FlitBit.Core.ICleanupScope.AddAction(System.Action)" inheritedFromTypeName="ICleanupScope" exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.NewOrSharedScope">
      <summary>
              Shares the ambient scope if it exists; otherwise, creates a new scope.
            </summary>
      <returns>a cleanup scope</returns>
    </member>
    <member name="E:FlitBit.Core.CleanupScope.ItemAdded">
      <summary>
              Event fired when items are added to he scope.
            </summary>
    </member>
    <member name="E:FlitBit.Core.CleanupScope.ItemDisposed">
      <summary>
              Event fired when items are disposed by the scope.
            </summary>
    </member>
    <member name="P:FlitBit.Core.CleanupScope.Current">
      <summary>
              Gets the current "ambient" cleanup scope. This is the nearest
              cleanup scope in the call stack.
            </summary>
    </member>
    <member name="T:FlitBit.Core.CleanupScopeItemEventArgs">
      <summary>
              Provides information about cleanup scope events.
            </summary>
    </member>
    <member name="M:FlitBit.Core.CleanupScopeItemEventArgs.#ctor(System.Object)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="item">the item that caused the event</param>
    </member>
    <member name="P:FlitBit.Core.CleanupScopeItemEventArgs.Item">
      <summary>
              The item that caused the event.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.BitFlags32">
      <summary>
              Utility class for working with bit/flags.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Collections.BitFlags32.Empty">
      <summary>
              Empty instance; all bits turned off.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.#ctor(System.Int32)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="flags">flag values</param>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.Equals(System.Object)">
      <summary>
              Determines if the flags are equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.GetHashCode">
      <summary>
              Gets a hashcode for the instance.
            </summary>
      <returns>a hashcode</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.ToString">
      <summary>
              Converts the bit vector into a bit string.
            </summary>
      <returns>bits string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.ExcludeFlags(System.Int32)">
      <summary>
              Excludes all of the flags given. (turns off bits corresponding to the bits given)
            </summary>
      <param name="flags">flags to turn off</param>
      <returns>the flags for chaining</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.IncludeFlags(System.Int32)">
      <summary>
              Includes all of the flags given. (turns on bits corresponding to the bits given)
            </summary>
      <param name="flags">flags to turn on</param>
      <returns>the flags for chaining</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.Off(System.Int32)">
      <summary>
              Turns the bit off at the position indicated.
            </summary>
      <param name="bit">bit position</param>
      <returns>flags with the indicated bit turned off</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.On(System.Int32)">
      <summary>
              Turns the bit on at the position indicated.
            </summary>
      <param name="bit">bit position</param>
      <returns>flags with the indicated bit turned on</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Equality(FlitBit.Core.Collections.BitFlags32,FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Equality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Implicit(FlitBit.Core.Collections.BitFlags32)~System.Int32">
      <summary>
              Implicit conversion operator from BitFlags to Int32.
            </summary>
      <param name="flags">value to convert</param>
      <returns>an Int32 representation of the flags</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Implicit(System.Int32)~FlitBit.Core.Collections.BitFlags32">
      <summary>
              Implicit converstion operator from Int32 to BitFlags32
            </summary>
      <param name="flags">value to convert</param>
      <returns>a BitFlags32</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Inequality(FlitBit.Core.Collections.BitFlags32,FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Inequality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are NOT equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.Equals(FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Determines if the flags are equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="P:FlitBit.Core.Collections.BitFlags32.Item(System.Int32)">
      <summary>
              Gets and sets bit values to ON (true) or OFF (false).
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitFlags32.IsEmpty">
      <summary>
              Indicates whether the bit flags are empty (none set to true).
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitFlags32.TrueFlagCount">
      <summary>
              Number of flags currently set to true.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.BitVector">
      <summary>
              Utility structure for working with bit values.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Collections.BitVector.Empty">
      <summary>
              Empty vector; all bits turned off.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.#ctor(System.Int32)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="count">Number of bits contained in the vector</param>
      <requires description="count must be greater than or equal to zero" csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Equals(System.Object)">
      <summary>
              Determines if the vector is equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.GetHashCode">
      <summary>
              Gets the hashcode for the vector.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.ToString">
      <summary>
              Converts the bit vector into a bit string.
            </summary>
      <returns>bits string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Copy">
      <summary>
              Makes a copy.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.GetFlags(System.Int32)">
      <summary>
              Gets the BitFlags32 at the index given.
            </summary>
      <param name="index" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.SetFlags(System.Int32,FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Sets the BitFlags32 at the index given.
            </summary>
      <param name="index" />
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.op_Equality(FlitBit.Core.Collections.BitVector,FlitBit.Core.Collections.BitVector)">
      <summary>
              Equality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.op_Inequality(FlitBit.Core.Collections.BitVector,FlitBit.Core.Collections.BitVector)">
      <summary>
              Inequality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are NOT equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Clone">
      <summary>
              Clones the current instance.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Equals(FlitBit.Core.Collections.BitVector)">
      <summary>
              Determines if the vector is equal to another.
            </summary>
      <param name="other">the other vector</param>
      <returns>true if equal; otherwise false.</returns>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.Item(System.Int32)">
      <summary>
              Gets and sets the bit at the index given.
            </summary>
      <param name="index">index of the bit to set or get; zero based.</param>
      <returns>whether the bit at the given index is turned on</returns>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.Count">
      <summary>
              Number of flags in the vector.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.IsEmpty">
      <summary>
              Determines if the vector is empty.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.TrueFlagCount">
      <summary>
              Number of flags currently set to true.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.EnumerableKeyValuePairs">
      <summary>
              Enumerable interface over key-value-pairs.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.EnumerableKeyValuePairs.#ctor(System.String,System.Char,System.Char)">
      <summary>
              Creates a new instance from an input string.
            </summary>
      <param name="input">The input string.</param>
      <param name="pairSep">The character that separates key value pairs</param>
      <param name="kvpSep">The character that separates keys from values</param>
      <requires exception="T:System.ArgumentNullException" csharp="input != null" vb="input &lt;&gt; Nothing">input != null</requires>
      <exception cref="T:System.ArgumentNullException">input == null</exception>
    </member>
    <member name="M:FlitBit.Core.Collections.EnumerableKeyValuePairs.GetEnumerator">
      <summary>
              Gets the enumerator.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="T:FlitBit.Core.Collections.Extensions">
      <summary>
              Contains utility extensions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.ReliableSetValue``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
      <summary>
              Reliably sets the value for a key in the concurrent dictionary.
            </summary>
      <typeparam name="TKey">key type K</typeparam>
      <typeparam name="TValue">value type V</typeparam>
      <param name="dictionary">the dictionary</param>
      <param name="key">the key</param>
      <param name="value">the value</param>
      <returns>
              If there is a value in the dictionary already associated with the key
              then that value is returned; otherwise default(V).
            </returns>
      <remarks>
              Because this method is performed on a concurrent dictionary in a non-blocking
              manner it is possible that parallel operations may change the value associated
              with the key concurrently. What this method guarantees is that the value
              associated with the key is set to the value given; not that it remains so.
              The result indicates the value that was replaced at the time the the operation
              succeeded.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Byte@)">
      <summary>
              Tries to get a named byte value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Boolean@)">
      <summary>
              Tries to get a named boolean value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Byte[]@)">
      <summary>
              Tries to get a named byte array value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Double@)">
      <summary>
              Tries to get a named double value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Decimal@)">
      <summary>
              Tries to get a named decimal value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Single@)">
      <summary>
              Tries to get a named float value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int16@)">
      <summary>
              Tries to get a named short value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int32@)">
      <summary>
              Tries to get a named int value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int64@)">
      <summary>
              Tries to get a named long value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int64@,System.Globalization.NumberStyles)">
      <summary>
              Tries to get a named boolean value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <param name="styles">number styles</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.String@)">
      <summary>
              Tries to get a named string value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.SByte@)">
      <summary>
              Tries to get a named signed byte value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.UInt16@)">
      <summary>
              Tries to get a named unsigned short value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.UInt32@)">
      <summary>
              Tries to get a named unsigned int value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.UInt64@)">
      <summary>
              Tries to get a named unsigned long value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="T:FlitBit.Core.Collections.KeyValuePair">
      <summary>
              Structure around a key-value-pair.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.#ctor(System.String,System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="k">the key</param>
      <param name="v">the value</param>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.Equals(System.Object)">
      <summary>
              Determines if the pair is equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>
        <em>true</em> if equal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.GetHashCode">
      <summary>
              Calculates the pair's hashcode.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.ToString">
      <summary>
              Converts the pair to a string representation.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.Equals(FlitBit.Core.Collections.KeyValuePair)">
      <summary>
              Determines if the pair is equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>
        <em>true</em> if equal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.ToString(System.Char)">
      <summary>
              Converts the pair to a string representation using the given separator.
            </summary>
      <param name="sep">a separator character</param>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.op_Equality(FlitBit.Core.Collections.KeyValuePair,FlitBit.Core.Collections.KeyValuePair)">
      <summary>
              Determines if two pairs are equal.
            </summary>
      <param name="lhs">left hand operand</param>
      <param name="rhs">right hand operand</param>
      <returns>
        <em>true</em> if equal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.op_Inequality(FlitBit.Core.Collections.KeyValuePair,FlitBit.Core.Collections.KeyValuePair)">
      <summary>
              Determines if two pairs are unequal.
            </summary>
      <param name="lhs">left hand operand</param>
      <param name="rhs">right hand operand</param>
      <returns>
        <em>true</em> if unequal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.TryParse(System.String,System.String,FlitBit.Core.Collections.KeyValuePair@)">
      <summary>
              Tries to parse a key-value-pair from an input string.
            </summary>
      <param name="input">the input</param>
      <param name="sep">string separating the key from the value</param>
      <param name="kvp">reference to a variable where the pair will be returned upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.TryParse(System.String,System.Char,FlitBit.Core.Collections.KeyValuePair@)">
      <summary>
              Tries to parse a key-value-pair from an input string.
            </summary>
      <param name="input">the input</param>
      <param name="sep">character separating the key from the value</param>
      <param name="kvp">reference to a variable where the pair will be returned upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
    </member>
    <member name="P:FlitBit.Core.Collections.KeyValuePair.Key">
      <summary>
              Gets the pair's key.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.KeyValuePair.Value">
      <summary>
              Gets the pair's value.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.NameValueCollectionExtensions">
      <summary>
              Contains extensions for NameValueCollection
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.FirstValueOrDefault``1(System.Collections.Specialized.NameValueCollection,System.String)">
      <summary>
              Transforms the value part of a name-value pair to type T if it
              is present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <returns>a result type T if the name-value pair is present; otherwise default(T)</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.FirstValueOrDefault``1(System.Collections.Specialized.NameValueCollection,System.String,System.Func{System.String,``0})">
      <summary>
              Transforms the value part of a name-value pair to type T if it
              is present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <param name="transform">optional function used to transform the value</param>
      <returns>a result type T if the name-value pair is present; otherwise default(T)</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.ToMultiValue``1(System.Collections.Specialized.NameValueCollection,System.String)">
      <summary>
              Transforms the multi-value part of a name-value pair to an array of type T
              if present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <returns>an enumeration of type T containing values</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.ToMultiValue``1(System.Collections.Specialized.NameValueCollection,System.String,System.Func{System.String,``0})">
      <summary>
              Transforms the multi-value part of a name-value pair to an array of type T
              if present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <param name="transform">transforms the string to result type T</param>
      <returns>an enumeration of type T containing values</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="T:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2">
      <summary>
              Base class for configuration element collections.
            </summary>
      <typeparam name="TElement">Element type</typeparam>
      <typeparam name="TKey">Key type</typeparam>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.#ctor(System.String,System.String,System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="addElmName">name used to add an element to the collection (default is 'add')</param>
      <param name="clearElmName">name used when clearing elements from the collection (default is 'clear')</param>
      <param name="removeElmName">name used to delete an element from the collection (default is 'remove')</param>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Add(`0)">
      <summary>
              Adds an element.
            </summary>
      <param name="item" />
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Clear">
      <summary>
              Clears the elements.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.IndexOf(`0)">
      <summary>
              Finds the index of an element.
            </summary>
      <param name="item">the element</param>
      <returns>the index of the element</returns>
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Remove(`0)">
      <summary>
              Removes an element.
            </summary>
      <param name="item">the element</param>
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Remove(`1)">
      <summary>
              Removes an element by key.
            </summary>
      <param name="key">the element's key</param>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.RemoveAt(System.Int32)">
      <summary>
              Removes an element at the given index.
            </summary>
      <param name="index">the element's index</param>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.PerformGetElementKey(`0)">
      <summary>
              Abstract method; gets the element's key.
            </summary>
      <param name="element">the element</param>
      <returns>the element's key</returns>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.CreateNewElement">
      <summary>
              Creates a new element of type TElement.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.CreateNewElement" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
              Gets the element's key.
            </summary>
      <param name="element">the element</param>
      <returns>the element's key</returns>
      <requires inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection" csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.GetEnumerator">
      <summary>
              Gets the enumerator.
            </summary>
      <returns>an enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Item(System.Int32)">
      <summary>
              Accesses an element by index.
            </summary>
      <param name="index">element index</param>
      <returns>
              the element at <paramref name="index" /></returns>
      <setter>
        <requires exception="T:System.ArgumentNullException" csharp="(object)value != null" vb="((Object)value) &lt;&gt; Nothing">(object)value != null</requires>
      </setter>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Item(`1)">
      <summary>
              Accesses a element by key.
            </summary>
      <param name="key">an element's key</param>
      <returns>the element with the given key</returns>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.CollectionType">
      <summary>
              CollectionType
            </summary>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Count">
      <summary>
              Number of elements.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Constants">
      <summary>
              Contains global constants.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Constants.NotSoRandomPrime">
      <summary>
              Prime seed for hashcodes; I chose this for its bit distribution. ~P
            </summary>
    </member>
    <member name="T:FlitBit.Core.DataGenerator">
      <summary>
              Utility class for generating random data.
            </summary>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.#ctor(FlitBit.Core.Buffers.IBufferReader)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="reader">A reader for interpreting the random bytes.</param>
      <requires exception="T:System.ArgumentNullException" csharp="reader != null" vb="reader &lt;&gt; Nothing">reader != null</requires>
      <exception cref="T:System.ArgumentNullException">reader == null</exception>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetArray``1(System.Int32)">
      <summary>
              Gets an array of random items.
            </summary>
      <typeparam name="T">item type T</typeparam>
      <param name="length">length of the new array</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetArray``1(System.Int32,System.Boolean)">
      <summary>
              Gets an array of random items.
            </summary>
      <typeparam name="T">item type T</typeparam>
      <param name="length">length of the new array</param>
      <param name="initializeEa">indicates whether each item is initialized with a random value</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetBoolean">
      <summary>
              Gets a random boolean value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetByte">
      <summary>
              Gets a random byte value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetBytes(System.Int32)">
      <summary>
              Gets an array of random byte values.
            </summary>
      <param name="len">Number of bytes in the array.</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetChar">
      <summary>
              Gets a random char value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetCharacterArray(System.Int32)">
      <summary>
              Gets an array of random char values.
            </summary>
      <param name="length">number of characters</param>
      <returns>the value</returns>
      <requires csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDateTime">
      <summary>
              Gets a random DateTime value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDateTimeOffset">
      <summary>
              Gets a random DateTime value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDecimal">
      <summary>
              Gets a random decimal value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDouble">
      <summary>
              Gets a random double floating point value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetEnum``1">
      <summary>
              Gets a random value of enum type E.
            </summary>
      <typeparam name="TEnum">type E</typeparam>
      <returns>the value</returns>
      <requires description="typeof E must be an enum" csharp="typeof(TEnum).IsEnum" vb="typeof(TEnum).IsEnum">typeof(TEnum).IsEnum</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetGuid">
      <summary>
              Gets a random guid value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetInt16">
      <summary>
              Gets a random Int16 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetInt32">
      <summary>
              Gets a random Int32 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetInt64">
      <summary>
              Gets a random Int64 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetNumericString(System.Int32)">
      <summary>
              Gets a string of random numeric values.
            </summary>
      <param name="len">number of characters</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetSByte">
      <summary>
              Gets a random signed-byte value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetSingle">
      <summary>
              Gets a random single floating point value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetString(System.Int32)">
      <summary>
              Gets a random string value.
            </summary>
      <param name="length">length of the string</param>
      <returns>the value</returns>
      <requires csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetStringWithLineBreaks(System.Int32)">
      <summary>
              Gets a random string value.
            </summary>
      <param name="length">length of the string</param>
      <returns>the value</returns>
      <requires csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetUInt16">
      <summary>
              Gets a random UInt16 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetUInt32">
      <summary>
              Gets a random UInt32 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetUInt64">
      <summary>
              Gets a random UInt64 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetWords(System.Int32)">
      <summary>
              Gets random fake-words.
            </summary>
      <param name="count">number of words to get.</param>
      <returns>words</returns>
      <requires csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
    </member>
    <member name="T:FlitBit.Core.Extensions">
      <summary>
              Various extension methods.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Extensions.CalculateCombinedHashcode``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
              Produces a combined hashcode from the enumerated items.
            </summary>
      <typeparam name="T">element type T</typeparam>
      <param name="items">an enumerable</param>
      <param name="seed">the hash seed (starting value)</param>
      <returns>the combined hashcode</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.CountBitsInFlag(System.UInt32)">
      <summary>
              Counts the number of bits turned on.
            </summary>
      <param name="value">a value</param>
      <returns>number of bits turned on</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.CountBitsInFlag(System.Int32)">
      <summary>
              Counts the number of bits turned on.
            </summary>
      <param name="value">a value</param>
      <returns>number of bits turned on</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.DoubleQuote(System.String)">
      <summary>
              Double quotes the given string, delimiting inner quotes.
            </summary>
      <param name="source" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Extensions.EqualsOrItemsEqual``1(``0[],``0[])">
      <summary>
              Determines if the arrays are equal or if the items in two different arrays
              are equal.
            </summary>
      <typeparam name="T">Item type T</typeparam>
      <param name="lhs">Left-hand comparand</param>
      <param name="rhs">Right-hand comparand</param>
      <returns>
        <b>true</b> if the arrays are equal or if the items in the arrays are equal.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.FormatForLogging(System.Exception)">
      <summary>
              Formats an exception for output into the log.
            </summary>
      <param name="ex">the exception</param>
      <returns>a string representation of the exception</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.FormatForLogging(System.Exception,System.Boolean)">
      <summary>
              Formats an exception for output into the log.
            </summary>
      <param name="ex">the exception</param>
      <param name="exposeStackTrace">indicates whether stack trace should be exposed in the output</param>
      <returns>a string representation of the exception</returns>
      <requires exception="T:System.ArgumentNullException" csharp="ex != null" vb="ex &lt;&gt; Nothing">ex != null</requires>
      <exception cref="T:System.ArgumentNullException">ex == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetFullName(System.Delegate)">
      <summary>
              Gets the fully qualified, human readable name for a delegate.
            </summary>
      <param name="d" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="d != null" vb="d &lt;&gt; Nothing">d != null</requires>
      <exception cref="T:System.ArgumentNullException">d == null</exception>
      <requires exception="T:System.ArgumentException" csharp="d.Method != (System.Reflection.MethodInfo)null" vb="d.Method &lt;&gt; ((System.Reflection.MethodInfo)Nothing) ">d.Method != (System.Reflection.MethodInfo)null</requires>
      <exception cref="T:System.ArgumentException">d.Method == null</exception>
      <requires exception="T:System.ArgumentException" csharp="d.Target != null" vb="d.Target &lt;&gt; Nothing">d.Target != null</requires>
      <exception cref="T:System.ArgumentException">d.Target == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetMemberFromExpression``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
      <summary>
              Gets a member from the expression given.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="expression">the expression</param>
      <returns>the expression's target member</returns>
      <requires exception="T:System.ArgumentNullException" csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <exception cref="T:System.ArgumentNullException">expression == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetReadableFullName(System.Type)">
      <summary>
              Gets a readable full name. Since this method uses reflection it should be used
              rarely. It was created to supply simpler type names when constructing error messages.
            </summary>
      <param name="type">The type.</param>
      <returns>A readable name such as My.Namespace.MyType&lt;string, int&gt;</returns>
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">type == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetReadableSimpleName(System.Type)">
      <summary>
              Gets a readable simple name for a type.
            </summary>
      <param name="type">the type</param>
      <returns>A readable name such as MyType&lt;string, int&gt;</returns>
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">type == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.JsonToDynamic(System.String)">
      <summary>
              Creates a dynamic object over the given JSON.
            </summary>
      <param name="json">JSON input</param>
      <returns>a dynamic object</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.RemoveTrailing(System.String,System.String)">
      <summary>
              Removes a string from the end of another string if present.
            </summary>
      <param name="target">The target string.</param>
      <param name="value">The value to remove.</param>
      <returns>the target string with the value removed</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.ToJson(System.Object)">
      <summary>
              Converts the source object to JSON
            </summary>
      <param name="source">the source</param>
      <returns>the JSON representation of the source</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
              Converts an enumerable to a readonly collection.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="collection">the collection</param>
      <returns>returns a read-only collection</returns>
    </member>
    <member name="T:FlitBit.Core.FactoryProvider">
      <summary>
              Accesses the current factory.
            </summary>
    </member>
    <member name="M:FlitBit.Core.FactoryProvider.SetFactoryProvider(FlitBit.Core.Factory.IFactoryProvider)">
      <summary>
              Sets the factory provider.
            </summary>
      <param name="provider" />
    </member>
    <member name="P:FlitBit.Core.FactoryProvider.Current">
      <summary>
              Gets the current factory provider.
            </summary>
    </member>
    <member name="P:FlitBit.Core.FactoryProvider.Factory">
      <summary>
              Gets and sets the global factory.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Factory.DefaultFactory">
      <summary>
              Factory capable of constructing auto-implemented types.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Factory.IFactory">
      <summary>
              Interface for classes that construct other classes.
            </summary>
      <remarks>
              This interface is used by the frameworks to decouple components from the underlying IoC container.
              While the FlitBit.IoC's IContainer is-a IFactory, it is a trivial matter to build adapters to
              other IoC containers by implementing IFactory to delegate to the IoC of your choice.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CanConstruct``1">
      <summary>
              Indicates whether the factory can construct typeof T.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CanConstruct(System.Type)">
      <summary>
              Indicates whether the factory can construct type.
            </summary>
      <param name="type" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CreateInstance``1">
      <summary>
              Creates a new instance of type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>a new instance</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.GetImplementationType``1">
      <summary>
              Gets the implementation type used when type T is constructed.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>If the factory can construct instances of type T, the implementation type used; otherwise null.</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.GetImplementationType(System.Type)">
      <summary>
              Gets the implementation type used when type is constructed
            </summary>
      <param name="type">Type</param>
      <returns>If the factory can construct instances of type, the implementation type used; otherwise null.</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.RegisterImplementationType``2">
      <summary>
              Notifies the factory that TImpl is an implementation that should be used to fulfill requests for type T.
            </summary>
      <typeparam name="T" />
      <typeparam name="TImpl" />
    </member>
    <member name="P:FlitBit.Core.Factory.IFactory.Next">
      <summary>
              Gets or sets the next factory when factories are chained.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CanConstruct(System.Type)">
      <summary>
              Determins if the factory can construct instances of type.
            </summary>
      <param name="type">The Type</param>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CreateInstance``1">
      <summary>
              Creates a new instance of type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CanConstruct``1">
      <summary>
              Determins if the factory can construct instances of type T.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.GetImplementationType``1">
      <summary>
              Gets the factory's implementation type for type T.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.GetImplementationType(System.Type)">
      <summary>
              Gets the factory's implementation type for type
            </summary>
      <param name="type">The type</param>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.RegisterImplementationType``2">
      <summary>
              Notifies the factory that TImpl is an implementation that should be used to fulfill requests for type T.
            </summary>
      <typeparam name="T" />
      <typeparam name="TImpl" />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.ParallelShare">
      <summary>
              This type sharable between threads as-is.
            </summary>
      <returns />
    </member>
    <member name="P:FlitBit.Core.Factory.DefaultFactory.Next">
      <summary>
              Gets or sets the next factory when chained.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Factory.IFactoryProvider">
      <summary>
              Interface for factory providers.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactoryProvider.GetFactory">
      <summary>
              Gets a factory.
            </summary>
      <returns />
    </member>
    <member name="T:FlitBit.Core.CodeContracts.ContractForICleanupScope">
      <summary>
              CodeContracts Class for ICleanupScope
            </summary>
    </member>
    <member name="T:FlitBit.Core.LogSink">
      <summary>
              Logging utilities.
            </summary>
    </member>
    <member name="M:FlitBit.Core.LogSink.OnTraceEvent``1(``0,System.Diagnostics.TraceEventType,System.String)">
      <summary>
              Notifies the log sink that the source object generated a trace event.
            </summary>
      <param name="source" />
      <param name="eventType" />
      <param name="message" />
      <typeparam name="T" />
    </member>
    <member name="M:FlitBit.Core.LogSink.ShouldTrace``1(``0,System.Diagnostics.TraceEventType)">
      <summary>
              Determines if trace events should be written when generated by the source object.
            </summary>
      <param name="source" />
      <param name="eventType" />
      <typeparam name="T" />
      <returns />
    </member>
    <member name="T:FlitBit.Core.Meta.AutoImplementedAttribute">
      <summary>
              Indicates that an implementation of the interface is generated.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.#ctor(FlitBit.Core.Meta.InstanceScopeKind)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="recommemdedScope">Recommended scope for the resultant type.</param>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.GetImplementation``1(FlitBit.Core.Factory.IFactory,System.Action{System.Type,System.Func{``0}})">
      <summary>
              Gets the implementation for target type T.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <param name="factory">the factory from which the type was requsted.</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if type T is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.GetImplementation(FlitBit.Core.Factory.IFactory,System.Type,System.Action{System.Type,System.Func{System.Object}})">
      <summary>
              Gets the implementation for type
            </summary>
      <param name="factory">the factory from which the type was requested.</param>
      <param name="type">the target types</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if <paramref name="type" /> is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Meta.AutoImplementedAttribute.RecommemdedScope">
      <summary>
              Indicates the recommended instance scope for implementations.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.DefaultImplementationAttribute">
      <summary>
              Indicates the default implementation of an interface.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.#ctor(FlitBit.Core.Meta.InstanceScopeKind,System.Type)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="recommemdedScope">Recommended scope for the resultant type.</param>
      <param name="defaultImplType">The default implementation used when non-other is contributed.</param>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.GetImplementation``1(FlitBit.Core.Factory.IFactory,System.Action{System.Type,System.Func{``0}})">
      <summary>
              Gets the implementation for target type T.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <param name="factory">the factory from which the type was requsted.</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if type T is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.GetImplementation(FlitBit.Core.Factory.IFactory,System.Type,System.Action{System.Type,System.Func{System.Object}})">
      <summary>
              Gets the implementation for type
            </summary>
      <param name="factory">the factory from which the type was requested.</param>
      <param name="type">the target types</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if <paramref name="type" /> is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Meta.DefaultImplementationAttribute.DefaultImplementationType">
      <summary>
              The default implementation used when non-other is contributed.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.InstanceScopeKind">
      <summary>
              Basic enumeration of instance scopes.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.InstanceScopeKind.OnDemand">
      <summary>
              Indicates that an instance has a natural scope.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.InstanceScopeKind.ContainerScope">
      <summary>
              Indicates that an instance has container scope.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.InstanceScopeKind.Singleton">
      <summary>
              Indicates that an instance is a singleton.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.SensitiveInfoKind">
      <summary>
              Enumeration of sensitivity kinds.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.SensitiveInfoKind.None">
      <summary>
              Indicates no sensitivity.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.SensitiveInfoKind.NoLog">
      <summary>
              Indicates the information should not be logged.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.SensitiveInfoKind.PersonallyIdentifying">
      <summary>
              Indicates the information is personally identifiable information.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.SensitiveInfoAttribute">
      <summary>
              Identifies a code element as Personally Identifiable Information
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.SensitiveInfoAttribute.#ctor(FlitBit.Core.Meta.SensitiveInfoKind)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="kind">the sensitivity kind</param>
    </member>
    <member name="P:FlitBit.Core.Meta.SensitiveInfoAttribute.Kind">
      <summary>
              Gets the sensitivity kind.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Net.HttpAuthenticationKind">
      <summary>
              Http authentication kinds.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.None">
      <summary>
              None.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.Basic">
      <summary>
              Indicates Basic authentication.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.Digest">
      <summary>
              Indicates digest authentication.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.Ntlm">
      <summary>
              Indicates NTLM authentication (Windows specific).
            </summary>
    </member>
    <member name="T:FlitBit.Core.Net.ResourceRequestExtensions">
      <summary>
              Extensions for resource oriented HTTP requests.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.ResourceRequestExtensions.ResourceClientString">
      <summary>
              String used as the Client in HTTP requests.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.DeserializeResponse``1(System.Net.HttpWebResponse)">
      <summary>
              Deserializes a response to an object of type T.
            </summary>
      <typeparam name="T">typeof T</typeparam>
      <param name="response">the web resposne</param>
      <returns>an instance of type T</returns>
      <requires description="response cannot be null" csharp="response != null" vb="response &lt;&gt; Nothing">response != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.DeserializeResponseAsDynamic(System.Net.HttpWebResponse)">
      <summary>
              Deserializes a response body as a dynamic object.
            </summary>
      <param name="response">the web response</param>
      <returns>a dynamic object over the response body</returns>
      <requires description="response cannot be null" csharp="response != null" vb="response &lt;&gt; Nothing">response != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.GetResponseBodyAsString(System.Net.HttpWebResponse)">
      <summary>
              Gets the response body from a web response.
            </summary>
      <param name="response">the web response</param>
      <returns>the full web response as text</returns>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpGet(System.Net.HttpWebRequest,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as JSON.
            </summary>
      <param name="req">the http request</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostJson``1(System.Net.HttpWebRequest,``0,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="after">an action to be called upon completion</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostJson``1(System.Net.HttpWebRequest,``0,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="encoding">the content encoding</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostXml(System.Net.HttpWebRequest,System.Xml.XmlDocument,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as XML.
            </summary>
      <param name="req">
              the http request
            </param>
      <param name="body">
              the post body
            </param>
      <param name="after">
              an action to be called upon completion
            </param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostXml(System.Net.HttpWebRequest,System.Xml.XmlDocument,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as XML.
            </summary>
      <param name="req">
              the http request
            </param>
      <param name="body">
              the post body
            </param>
      <param name="encoding">
              the content encoding
            </param>
      <param name="after">
              an action to be called upon completion
            </param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="body != null" vb="body &lt;&gt; Nothing">body != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutJson``1(System.Net.HttpWebRequest,``0,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="after">an action to be called upon completion</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutJson``1(System.Net.HttpWebRequest,``0,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="encoding">the content encoding</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutText(System.Net.HttpWebRequest,System.String,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>Performs an HTTP PUT against a URI as text.</summary>
      <param name="req">The request.</param>
      <param name="body">The body.</param>
      <param name="after">The continuation to be executed after.</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutText(System.Net.HttpWebRequest,System.String,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>Performs an HTTP PUT against a URI as text.</summary>
      <param name="req">The request.</param>
      <param name="body">The body.</param>
      <param name="encoding">The content encoding.</param>
      <param name="after">The continuation to be executed after.</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutXml(System.Net.HttpWebRequest,System.Xml.Linq.XElement,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as XML.
            </summary>
      <param name="req">the http request</param>
      <param name="body">the post body</param>
      <param name="after">an action to be called upon completion</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutXml(System.Net.HttpWebRequest,System.Xml.Linq.XElement,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as XML.
            </summary>
      <param name="req">the http request</param>
      <param name="body">the post body</param>
      <param name="encoding">the content encoding</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="body != null" vb="body &lt;&gt; Nothing">body != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.IsSuccess(System.Net.HttpStatusCode)">
      <summary>
              Determines if an HTTP status code indicates succes (within the 200 range).
            </summary>
      <param name="code" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.MakeResourceRequest(System.Uri)">
      <summary>
              Given a URI, makes a web request.
            </summary>
      <param name="uri">the URI</param>
      <returns>a web request</returns>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.MakeResourceRequest(System.Uri,System.Boolean)">
      <summary>
              Given a URI, makes a web request.
            </summary>
      <param name="uri">the URI</param>
      <param name="keepAlive">indicates whether keepalive should be set for the connection</param>
      <returns>a web request</returns>
      <requires exception="T:System.ArgumentNullException" csharp="uri != (System.Uri)null" vb="uri &lt;&gt; ((System.Uri)Nothing) ">uri != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">uri == null</exception>
      <requires description="URI must be http(s) scheme" exception="T:System.ArgumentException" csharp="uri.Scheme != default(string) &amp;&amp; uri.Scheme.StartsWith(&quot;http&quot;)" vb="uri.Scheme &lt;&gt; Nothing AndAlso uri.Scheme.StartsWith(&quot;http&quot;)">uri.Scheme != default(string) &amp;&amp; uri.Scheme.StartsWith("http")</requires>
      <exception cref="T:System.ArgumentException">uri.Scheme == null || !(uri.Scheme.StartsWith("http"))</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelDelete``1(System.Net.HttpWebRequest,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP DELETE.
            </summary>
      <param name="req">the web request on which to perform the DELETE.</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelGet``1(System.Uri,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Performs an HTTP GET against a URI.
            </summary>
      <param name="uri">the uri</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="uri != (System.Uri)null" vb="uri &lt;&gt; ((System.Uri)Nothing) ">uri != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">uri == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelGet``1(System.Net.HttpWebRequest,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP GET.
            </summary>
      <param name="req">the web request on which to perform the GET.</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelPost``1(System.Net.HttpWebRequest,System.Byte[],System.String,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP POST.
            </summary>
      <param name="req">the web request on which to perform the POST.</param>
      <param name="postBody">array of bytes containing the post body</param>
      <param name="contentType">indicates the post body's content type</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelPut``1(System.Net.HttpWebRequest,System.Byte[],System.String,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP PUT.
            </summary>
      <param name="req">the web request on which to perform the PUT.</param>
      <param name="postBody">array of bytes containing the post body</param>
      <param name="contentType">indicates the post body's content type</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.WithBasicAuth(System.Net.HttpWebRequest,System.String,System.String)">
      <summary>
              Adds HTTP Basic Auth to the request.
            </summary>
      <param name="req">the request</param>
      <param name="username">a username</param>
      <param name="password">a password</param>
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="username != null" vb="username &lt;&gt; Nothing">username != null</requires>
      <exception cref="T:System.ArgumentNullException">username == null</exception>
      <requires exception="T:System.ArgumentException" csharp="username.Length &gt; 0" vb="username.Length &gt; 0">username.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">username.Length &lt;= 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="password != null" vb="password &lt;&gt; Nothing">password != null</requires>
      <exception cref="T:System.ArgumentNullException">password == null</exception>
      <requires exception="T:System.ArgumentException" csharp="password.Length &gt; 0" vb="password.Length &gt; 0">password.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">password.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.Parallel.AsyncResult">
      <summary>
              Basic implementation of the ITaskCompletion interface.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.#ctor(System.AsyncCallback,System.Object)">
      <summary>
              Creates a new instance and initializes the AsyncCallback.
            </summary>
      <param name="asyncCallback">A delegate to be called when the async operation completes.</param>
      <param name="asyncHandback">A handback object passed to the AsyncCallback when the operation completes.</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.#ctor(System.AsyncCallback,System.Object,System.Object)">
      <summary>
              Creates a new instance and initializes the AsyncCallback.
            </summary>
      <param name="asyncCallback">A delegate to be called when the async operation completes.</param>
      <param name="asyncHandback">A handback object passed to the AsyncCallback when the operation completes.</param>
      <param name="asyncState">A state object for use as a handback for the creator.</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.#ctor(FlitBit.Core.Parallel.IFuture{System.Boolean})">
      <summary>
              Creates a new instance.
            </summary>
      <requires exception="T:System.ArgumentNullException" csharp="future != null" vb="future &lt;&gt; Nothing">future != null</requires>
      <exception cref="T:System.ArgumentNullException">future == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.EndInvoke">
      <summary>
              Ends the asynchronous operation.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.EndInvoke(System.TimeSpan,System.Boolean)">
      <summary>
              Ends the asynchronous operation.
            </summary>
      <param name="timeout" />
      <param name="exitContext" />
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.EndInvoke(System.Int32,System.Boolean)">
      <summary>
              Ends the asynchronous operation.
            </summary>
      <param name="millisecondsTimeout" />
      <param name="exitContext" />
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.PerformDispose(System.Boolean)">
      <summary>
              Performs a disposal of the async result.
            </summary>
      <param name="disposing" />
      <returns />
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.AsyncHandback">
      <summary>
              Gets the handback object given at the asynchronous operations begin.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.Exception">
      <summary>
              Gets the exception that caused the fault.
            </summary>
      <getter>
        <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      </getter>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.IsFaulted">
      <summary>
              Indicates whether the asynchronous operation resulted in a fault.
            </summary>
      <getter>
        <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      </getter>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.AsyncState">
      <summary>
              Gets the task's asynchronous state.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.CompletedSynchronously">
      <summary>
              Indicates whether the task completed synchronously.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.AsyncWaitHandle">
      <summary>
              Gets the task's wait handle.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.IAsyncResult.get_AsyncWaitHandle" inheritedFromTypeName="IAsyncResult" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:FlitBit.Core.Parallel.AsyncResult.IsCompleted">
      <summary>
              Gets a value indicating whether the asynchronous operation has completed.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.Completion">
      <summary>
              Default waitable implementation.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.#ctor(System.Object)">
      <summary>
              Constructs a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.#ctor(System.Object,System.Boolean)">
      <summary>
              Constructs a new instance.
            </summary>
      <param name="target">action's target</param>
      <param name="completed">
              Indicates whether the wait has already
              completed.
            </param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.Continue(FlitBit.Core.Parallel.Continuation)">
      <summary>
              Schedules an action to execute when this completion is done.
            </summary>
      <param name="continuation">a continuation to run upon completion.</param>
      <requires exception="T:System.ArgumentNullException" csharp="continuation != null" vb="continuation &lt;&gt; Nothing">continuation != null</requires>
      <exception cref="T:System.ArgumentNullException">continuation == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.ContinueWithCompletion(FlitBit.Core.Parallel.Continuation)">
      <summary>
              Schedules an action to execute when another completion succeeds.
            </summary>
      <param name="continuation">an action to run when the completion succeeds</param>
      <returns>a completion for the success action</returns>
      <requires exception="T:System.ArgumentNullException" csharp="continuation != null" vb="continuation &lt;&gt; Nothing">continuation != null</requires>
      <exception cref="T:System.ArgumentNullException">continuation == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.ContinueWithCompletion``1(FlitBit.Core.Parallel.ContinuationFunc{``0})">
      <summary>
              Schedules a function to execute when another completion succeeds.
            </summary>
      <typeparam name="TResult">result type R</typeparam>
      <param name="continuation">a function to run when the completion succeeds</param>
      <returns>a completion for the success function</returns>
      <requires exception="T:System.ArgumentNullException" csharp="continuation != null" vb="continuation &lt;&gt; Nothing">continuation != null</requires>
      <exception cref="T:System.ArgumentNullException">continuation == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.MakeAsyncCallback``1(``0,System.Action{System.IAsyncResult,``0})">
      <summary>
              Makes an AsyncCallback delegate that produces the completion.
            </summary>
      <typeparam name="THandback">handback type H</typeparam>
      <param name="handback">the handback</param>
      <param name="handler">a handler that produces the completion</param>
      <returns>An AsyncCallback.</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.MarkCompleted">
      <summary>
              Marks the completion.
            </summary>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.MarkFaulted(System.Exception)">
      <summary>
              Marks the completion.
            </summary>
      <param name="fault" />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.ToAsyncResult">
      <summary>
              Gets an async result for .NET framework synchronization.
            </summary>
      <returns />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.ToAsyncResult(System.AsyncCallback,System.Object)">
      <summary>
              Gets an async result for .NET framework synchronization.
            </summary>
      <param name="asyncCallback" />
      <param name="asyncHandback" />
      <returns />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.ToAsyncResult(System.AsyncCallback,System.Object,System.Object)">
      <summary>
              Gets an async result for .NET framework synchronization.
            </summary>
      <param name="asyncCallback" />
      <param name="asyncHandback" />
      <param name="asyncState" />
      <returns />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.Wait(System.TimeSpan)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="timeout">A timespan representing the timeout period.</param>
      <returns>The future's value.</returns>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion.PerformDispose(System.Boolean)">
      <summary>
              Performs dispose on the completion.
            </summary>
      <param name="disposing" />
      <returns />
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion.Exception">
      <summary>
              Gets the exception that caused the fault.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion.IsCompleted">
      <summary>
              Indicates whether the wait has completed.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion.IsFaulted">
      <summary>
              Determines if the completion resulted in an error.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion.Target">
      <summary>
              The completion's target object if given when the completion was created.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion.WaitHandle">
      <summary>
              Gets a wait handle for the completion.
            </summary>
      <getter>
        <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      </getter>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="T:FlitBit.Core.Parallel.Completion`1">
      <summary>
              Default waitable implementation.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.#ctor(System.Object)">
      <summary>
              Constructs a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.#ctor(System.Object,System.Boolean,`0)">
      <summary>
              Constructs a new instance.
            </summary>
      <param name="target">action's target</param>
      <param name="completed">
              Indicates whether the wait has already
              completed.
            </param>
      <param name="value">the completion value</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.AwaitValue">
      <summary>
              Waits (blocks the current thread) until the value is present.
            </summary>
      <returns>The future's value.</returns>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.AwaitValue(System.Int32)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="millisecondsTimeout">Timeout in milliseconds.</param>
      <returns>The future's value.</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelTimeoutException">thrown if the timeout is exceeded before the value becomes available.</exception>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.AwaitValue(System.TimeSpan)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="timeout">A timespan representing the timeout period.</param>
      <returns>The future's value.</returns>
      <exception cref="T:System.TimeoutException">thrown if the timeout is exceeded before the value becomes available.</exception>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.Continue(FlitBit.Core.Parallel.Continuation{`0})">
      <summary>
              Schedules an action to execute when this completion is done.
            </summary>
      <param name="continuation">a continuation to run upon completion.</param>
      <requires exception="T:System.ArgumentNullException" csharp="continuation != null" vb="continuation &lt;&gt; Nothing">continuation != null</requires>
      <exception cref="T:System.ArgumentNullException">continuation == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.ContinueWithCompletion(FlitBit.Core.Parallel.Continuation{`0})">
      <summary>
              Schedules an action to execute when another completion succeeds.
            </summary>
      <param name="continuation">an action to run when the completion succeeds</param>
      <returns>a completion for the success action</returns>
      <requires exception="T:System.ArgumentNullException" csharp="continuation != null" vb="continuation &lt;&gt; Nothing">continuation != null</requires>
      <exception cref="T:System.ArgumentNullException">continuation == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.ContinueWithCompletion``1(FlitBit.Core.Parallel.ContinuationFunc{`0,``0})">
      <summary>
              Schedules a function to execute when another completion succeeds.
            </summary>
      <typeparam name="TResult">result type R</typeparam>
      <param name="continuation">a function to run when the completion succeeds</param>
      <returns>a completion for the success function</returns>
      <requires exception="T:System.ArgumentNullException" csharp="continuation != null" vb="continuation &lt;&gt; Nothing">continuation != null</requires>
      <exception cref="T:System.ArgumentNullException">continuation == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.MakeAsyncCallback``1(``0,System.Func{System.IAsyncResult,``0,`0})">
      <summary>
              Makes an AsyncCallback delegate that produces the completion.
            </summary>
      <typeparam name="THandback">handback type H</typeparam>
      <param name="handback">the handback</param>
      <param name="handler">a handler that produces the completion</param>
      <returns>An AsyncCallback.</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.MarkCompleted(`0)">
      <summary>
              Marks the completion.
            </summary>
      <param name="value">the completion value</param>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.MarkFaulted(System.Exception)">
      <summary>
              Marks the completion.
            </summary>
      <param name="fault" />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.ToAsyncResult">
      <summary>
              Gets an async result for .NET framework synchronization.
            </summary>
      <returns />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.ToAsyncResult(System.AsyncCallback,System.Object)">
      <summary>
              Gets an async result for .NET framework synchronization.
            </summary>
      <param name="asyncCallback" />
      <param name="asyncHandback" />
      <returns />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.ToAsyncResult(System.AsyncCallback,System.Object,System.Object)">
      <summary>
              Gets an async result for .NET framework synchronization.
            </summary>
      <param name="asyncCallback" />
      <param name="asyncHandback" />
      <param name="asyncState" />
      <returns />
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.Wait(System.TimeSpan)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="timeout">A timespan representing the timeout period.</param>
      <returns>The future's value.</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Completion`1.PerformDispose(System.Boolean)">
      <summary>
              Performs dispose on the completion.
            </summary>
      <param name="disposing" />
      <returns />
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion`1.Exception">
      <summary>
              Gets the exception that caused the fault.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion`1.IsCompleted">
      <summary>
              Indicates whether the wait has completed.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion`1.IsFaulted">
      <summary>
              Determines if the completion resulted in an error.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion`1.Target">
      <summary>
              The completion's target object if given when the completion was created.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Completion`1.WaitHandle">
      <summary>
              Gets a wait handle for the completion.
            </summary>
      <getter>
        <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      </getter>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="T:FlitBit.Core.Parallel.CompletionEventArgs">
      <summary>
              Completion event arguments.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.CompletionEventArgs.#ctor(FlitBit.Core.Parallel.Completion)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="completion">the completion</param>
    </member>
    <member name="P:FlitBit.Core.Parallel.CompletionEventArgs.Completion">
      <summary>
              The completion upon which the event fired.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.ContextFlow">
      <summary>
              Utility class for managing context flow.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.PerformDispose(System.Boolean)">
      <summary>
              Performs the disposal.
            </summary>
      <param name="disposing">indicates whether the context is disposing</param>
      <returns>
        <em>true</em> if disposed as a result of the call; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.EnsureAmbient(FlitBit.Core.Parallel.ContextFlow)">
      <summary>
              Attaches the given context to the current thread.
            </summary>
      <param name="ambient">a new ambient context</param>
      <returns>the provided context</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.ForkAmbient">
      <summary>
              Prepares a copy of the context for use in thread-pool and background threads.
            </summary>
      <returns>an instance suitable for use as a background thread's ambient context</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Push``1(``0)">
      <summary>
              Pushes an instance of T onto the context.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="ambient">an instance</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.TryPeek``1(``0@)">
      <summary>
              Tries to peek at an ambient instance of type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="ambient">variable where the instance will be returned upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.TryPop``1(``0)">
      <summary>
              Tries to pop at an ambient instance of type T off the context.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="comparand">an instance for comparison</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="P:FlitBit.Core.Parallel.ContextFlow.Current">
      <summary>
              Gets the current "ambient" context.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.Continuation">
      <summary>
              Continuation delegate.
            </summary>
      <param name="fault">an exception raised by the operation</param>
      <remarks>
              Continuations are invoked when the operation on
              which they depend reaches completion. Continuations always
              receive an exception as their first argument. In success
              cases, the <paramref name="fault" /> argument will be null; otherwise
              it is the exception raised by the operation being continued.
            </remarks>
    </member>
    <member name="T:FlitBit.Core.Parallel.Continuation`1">
      <summary>
              Continuation delegate.
            </summary>
      <typeparam name="T">item type T, usually the result type of the operation being continued.</typeparam>
      <param name="fault">an exception raised by the operation</param>
      <param name="item">the result of the continued operation (when the operation is a Fun&lt;&gt;)</param>
      <remarks>
              Continuations are invoked when the operation on
              which they depend reaches completion. Continuations always
              receive an exception as their first argument. In success
              cases, the <paramref name="fault" /> argument will be null; otherwise
              it is the exception raised by the operation being continued.
            </remarks>
    </member>
    <member name="T:FlitBit.Core.Parallel.ContinuationFunc`1">
      <summary>
              Continuation delegate.
            </summary>
      <typeparam name="TResult">result type R</typeparam>
      <param name="fault">an exception raised by the operation</param>
      <returns>a return item</returns>
      <remarks>
              Continuations are invoked when the operation on
              which they depend reaches completion. Continuations always
              receive an exception as their first argument. In success
              cases, the <paramref name="fault" /> argument will be null; otherwise
              it is the exception raised by the operation being continued.
            </remarks>
    </member>
    <member name="T:FlitBit.Core.Parallel.ContinuationFunc`2">
      <summary>
              Continuation delegate.
            </summary>
      <typeparam name="T">item type T, usually the result type of the operation being continued.</typeparam>
      <typeparam name="TResult">result type R</typeparam>
      <param name="fault">an exception raised by the operation</param>
      <param name="item">the result of the continued operation (when the operation is a Fun&lt;&gt;)</param>
      <returns>a return item</returns>
      <remarks>
              Continuations are invoked when the operation on
              which they depend reaches completion. Continuations always
              receive an exception as their first argument. In success
              cases, the <paramref name="fault" /> argument will be null; otherwise
              it is the exception raised by the operation being continued.
            </remarks>
    </member>
    <member name="T:FlitBit.Core.Parallel.ContinuationSet">
      <summary>
              A set of continuations, each signaled once.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.CompletionEventArgs`1">
      <summary>
              Completion event arguments.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.CompletionEventArgs`1.#ctor(FlitBit.Core.Parallel.Completion{`0})">
      <summary>
              Creates a new instance.
            </summary>
      <param name="completion">the completion</param>
    </member>
    <member name="P:FlitBit.Core.Parallel.CompletionEventArgs`1.Completion">
      <summary>
              Gets the completion upon which the event fired.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.ContinuationSet`1">
      <summary>
              A set of continuations, each signaled once.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.Go">
      <summary>
              Parallelism utilities.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Go.NotifyUncaughtException(System.Object,System.Exception)">
      <summary>
              Notifies event handlers that an exception has occurred in a paralle operation.
            </summary>
      <param name="sender">the sender</param>
      <param name="e">the exception that was raised.</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Go.Parallel(System.Action)">
      <summary>
              Performs an action in parallel.
            </summary>
      <param name="action">an action</param>
      <requires exception="T:System.ArgumentNullException" csharp="new FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClass1(){
    action = action, 
}.action != null" vb="(() =&gt; {
    FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClass1 local_0_prime = New FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClass1();
    (local_0_prime.action = action)
    return local_0_prime; })().action &lt;&gt; Nothing">new FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClass1(){
    action = action, 
}.action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Go.Parallel(System.Action,FlitBit.Core.Parallel.Continuation)">
      <summary>
              Performs an action in parallel.
            </summary>
      <param name="action">an action</param>
      <param name="continuation">a continuation called upon completion.</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Go.Parallel``1(System.Func{``0},FlitBit.Core.Parallel.Continuation{``0})">
      <summary>
              Performs the function in parallel.
            </summary>
      <typeparam name="TResult">result type R</typeparam>
      <param name="fun">an action</param>
      <param name="continuation">a continuation called upon completion.</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Go.ParallelWithCompletion(System.Action)">
      <summary>
              Performs an action in parallel.
            </summary>
      <param name="action">an action</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="new FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassa(){
    action = action, 
}.action != null" vb="(() =&gt; {
    FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassa local_0_prime = New FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassa();
    (local_0_prime.action = action)
    return local_0_prime; })().action &lt;&gt; Nothing">new FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassa(){
    action = action, 
}.action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Parallel.Go.ParallelWithCompletion``1(System.Func{``0})">
      <summary>
              Performs the function in parallel.
            </summary>
      <typeparam name="TResult">result type R</typeparam>
      <param name="fun">an action</param>
      <returns>a completion where the results will be returned upon completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="new FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassd&lt;TResult&gt;(){
    fun = fun, 
}.fun != null" vb="(() =&gt; {
    FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassd&lt;TResult&gt; local_0_prime = New FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassd(Of TResult)();
    (local_0_prime.fun = fun)
    return local_0_prime; })().fun &lt;&gt; Nothing">new FlitBit.Core.Parallel.Go.&lt;&gt;c__DisplayClassd&lt;TResult&gt;(){
    fun = fun, 
}.fun != null</requires>
      <exception cref="T:System.ArgumentNullException">fun == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="E:FlitBit.Core.Parallel.Go.OnUncaughtException">
      <summary>
              Event fired when uncaught exceptions are raised by parallel operations.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.DemuxResultKind">
      <summary>
              Indicates kind of results when de-multiplexing.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.DemuxResultKind.None">
      <summary>
              None.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.DemuxResultKind.Observed">
      <summary>
              The result was observed. This indicates the current thread observed a result
              originated by another thread.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.DemuxResultKind.Originated">
      <summary>
              The result was originated by the current thread.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.DemuxProducer`2">
      <summary>
              Produces a result type R, given an argument type A, demultiplexing concurrent requests.
            </summary>
      <typeparam name="TArgs">argument type A</typeparam>
      <typeparam name="TResult">result type R</typeparam>
    </member>
    <member name="M:FlitBit.Core.Parallel.DemuxProducer`2.TryConsume(`0,FlitBit.Core.Parallel.Continuation{System.Tuple{FlitBit.Core.Parallel.DemuxResultKind,`1}})">
      <summary>
              Tries to demux a completion result.
            </summary>
      <param name="args" />
      <param name="consumer">A continuation called upon completion.</param>
      <requires exception="T:System.ArgumentNullException" csharp="consumer != null" vb="consumer &lt;&gt; Nothing">consumer != null</requires>
      <exception cref="T:System.ArgumentNullException">consumer == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.DemuxProducer`2.ProduceResult(`0,`1@)">
      <summary>
              Produces the requested result.
            </summary>
      <param name="arg" />
      <param name="value" />
      <returns />
    </member>
    <member name="T:FlitBit.Core.Parallel.ParallelException">
      <summary>
              Base exception thrown by the parallel framework.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelException.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelException.#ctor(System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="message">an error message</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelException.#ctor(System.String,System.Exception)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="message">an error message</param>
      <param name="cause">an inner exception that caused this exception</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Used by serialization to create an instance.
            </summary>
      <param name="si" />
      <param name="sc" />
    </member>
    <member name="T:FlitBit.Core.Parallel.ParallelTimeoutException">
      <summary>
              Exception indicating a task timed out before completion.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelTimeoutException.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelTimeoutException.#ctor(System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="message">an error message</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelTimeoutException.#ctor(System.String,System.Exception)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="message">an error message</param>
      <param name="cause">an inner exception that caused this exception</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ParallelTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Used by serialization to create an instance.
            </summary>
      <param name="si" />
      <param name="sc" />
    </member>
    <member name="T:FlitBit.Core.Parallel.Future`1">
      <summary>
              A Future variable of type T.
            </summary>
      <typeparam name="T">variable type T</typeparam>
    </member>
    <member name="T:FlitBit.Core.Parallel.IFuture`1">
      <summary>
              Interface for strongly typed future variables.
            </summary>
      <typeparam name="T">variable type T</typeparam>
    </member>
    <member name="T:FlitBit.Core.Parallel.IFuture">
      <summary>
              Base interface for future variables.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture.Wait(System.TimeSpan)">
      <summary>
              Waits for the future to be completed.
            </summary>
      <param name="timeout">the timeout period.</param>
      <returns>
        <em>true</em> if completed; otherwise <em>false</em>.
            </returns>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="P:FlitBit.Core.Parallel.IFuture.Exception">
      <summary>
              If faulted gets the associated exception.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.IFuture.IsCompleted">
      <summary>
              Indicates whether the future is completed.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.IFuture.IsFaulted">
      <summary>
              Determines producing the future caused a fault.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.IFuture.SyncObject">
      <summary>
              Gets the future's synchronization object.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.IFuture.WaitHandle">
      <summary>
              Gets a wait handle for the future.
            </summary>
      <getter>
        <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      </getter>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.AwaitValue">
      <summary>
              Awaits the future's value.
            </summary>
      <returns>the variable's value.</returns>
      <exception cref="T:System.Exception">thrown if production of the future caused a fault.</exception>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.AwaitValue(System.Int32)">
      <summary>
              Waits for a period of time for the future's value.
            </summary>
      <param name="millisecondsTimeout">a timeout period in milliseconds.</param>
      <returns>the variable's value.</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelException">thrown if production of the future caused a fault.</exception>
      <exception cref="T:System.TimeoutException">thrown if the future has not completed in the timeout period.</exception>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.AwaitValue(System.TimeSpan)">
      <summary>
              Waits for a period of time for the future's value.
            </summary>
      <param name="timeout">a timeout period</param>
      <returns>the variable's value.</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelException">thrown if production of the future caused a fault.</exception>
      <exception cref="T:System.TimeoutException">thrown if the future has not completed in the timeout period.</exception>
      <requires exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.MarkCompleted(`0)">
      <summary>
              Marks the completion.
            </summary>
      <param name="value" />
      <requires exception="T:System.InvalidOperationException" csharp="!this.IsCompleted" vb="Not Me.IsCompleted">!this.IsCompleted</requires>
      <exception cref="T:System.InvalidOperationException">IsCompleted</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.MarkFaulted(System.Exception)">
      <summary>
              Marks the completion.
            </summary>
      <param name="fault" />
      <requires exception="T:System.InvalidOperationException" csharp="!this.IsCompleted" vb="Not Me.IsCompleted">!this.IsCompleted</requires>
      <exception cref="T:System.InvalidOperationException">IsCompleted</exception>
      <requires exception="T:System.ArgumentNullException" csharp="fault != null" vb="fault &lt;&gt; Nothing">fault != null</requires>
      <exception cref="T:System.ArgumentNullException">fault == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.TryGetValue(`0@)">
      <summary>
              Tries to get the future's value, blocking the current thread until it is available.
            </summary>
      <param name="value">variable where the value will be returned.</param>
      <returns>true if the value is returned; otherwise false</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelException">thrown if production of the future caused a fault.</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.TryGetValue(System.Int32,`0@)">
      <summary>
              Tries to get the future's value, blocking the current thread for the timeout period.
            </summary>
      <param name="millisecondsTimeout">a timeout period in milliseconds.</param>
      <param name="value">variable where the value will be returned.</param>
      <returns>true if the value is returned; otherwise false</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelException">thrown if production of the future caused a fault.</exception>
      <exception cref="T:System.TimeoutException">thrown if the future has not completed in the timeout period.</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.IFuture`1.TryGetValue(System.TimeSpan,`0@)">
      <summary>
              Tries to get the future's value, blocking the current thread for the timeout period.
            </summary>
      <param name="timeout">a timeout period</param>
      <param name="value">variable where the value will be returned.</param>
      <returns>true if the value is returned; otherwise false</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelException">thrown if production of the future caused a fault.</exception>
      <exception cref="T:System.TimeoutException">thrown if the future has not completed in the timeout period.</exception>
    </member>
    <member name="P:FlitBit.Core.Parallel.IFuture`1.Value">
      <summary>
              Gets the future's value, blocking the current thread until it is available.
            </summary>
      <returns>the future's value</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelException">thrown if production of the future caused a fault.</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.#ctor">
      <summary>
              Constructs a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.#ctor(`0)">
      <summary>
              Constructs a new instance.
            </summary>
      <param name="value">the future's value</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.PerformDispose(System.Boolean)">
      <summary>
              Disposes the future and it's wait handle.
            </summary>
      <param name="disposing">indicates whether the object is disposing</param>
      <returns>if disposing, returns true if the disposal should continue.</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.MarkCompleted(`0)">
      <summary>
              Marks the completion.
            </summary>
      <param name="value" />
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture`1.MarkCompleted(`0)" inheritedFromTypeName="IFuture" exception="T:System.InvalidOperationException" csharp="!this.IsCompleted" vb="Not Me.IsCompleted">!this.IsCompleted</requires>
      <exception cref="T:System.InvalidOperationException">IsCompleted</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.MarkFaulted(System.Exception)">
      <summary>
              Marks the completion.
            </summary>
      <param name="fault" />
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture`1.MarkFaulted(System.Exception)" inheritedFromTypeName="IFuture" exception="T:System.InvalidOperationException" csharp="!this.IsCompleted" vb="Not Me.IsCompleted">!this.IsCompleted</requires>
      <exception cref="T:System.InvalidOperationException">IsCompleted</exception>
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture`1.MarkFaulted(System.Exception)" inheritedFromTypeName="IFuture" exception="T:System.ArgumentNullException" csharp="fault != null" vb="fault &lt;&gt; Nothing">fault != null</requires>
      <exception cref="T:System.ArgumentNullException">fault == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.Wait(System.TimeSpan)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="timeout">A timespan representing the timeout period.</param>
      <returns>
        <em>true</em> if the value is present; otherwise <em>false</em>.
            </returns>
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture.Wait(System.TimeSpan)" inheritedFromTypeName="IFuture" exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.TryGetValue(`0@)">
      <summary>
              Tries to read the value. This call will not block the calling
              thread if the value is not present.
            </summary>
      <param name="value">
              A reference where the value will be written if
              it is present.
            </param>
      <returns>
        <em>true</em> if the value was successfully read; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.TryGetValue(System.Int32,`0@)">
      <summary>
              Tries to read the value. This call will not block the calling
              thread for the period of the timeout if the value is not present.
            </summary>
      <param name="millisecondsTimeout">timeout in milliseconds</param>
      <param name="value">
              A reference where the value will be written if
              it is present.
            </param>
      <returns>
        <em>true</em> if the value was successfully read; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.TryGetValue(System.TimeSpan,`0@)">
      <summary>
              Tries to read the value. This call will not block the calling
              thread for the period of the timeout if the value is not present.
            </summary>
      <param name="timeout">the timeout</param>
      <param name="value">
              A reference where the value will be written if
              it is present.
            </param>
      <returns>
        <em>true</em> if the value was successfully read; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.AwaitValue">
      <summary>
              Waits (blocks the current thread) until the value is present.
            </summary>
      <returns>The future's value.</returns>
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture`1.AwaitValue" inheritedFromTypeName="IFuture" exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.AwaitValue(System.Int32)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="millisecondsTimeout">Timeout in milliseconds.</param>
      <returns>The future's value.</returns>
      <exception cref="T:FlitBit.Core.Parallel.ParallelTimeoutException">thrown if the timeout is exceeded before the value becomes available.</exception>
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture`1.AwaitValue(System.Int32)" inheritedFromTypeName="IFuture" exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Future`1.AwaitValue(System.TimeSpan)">
      <summary>
              Waits (blocks the current thread) until the value is present or the timeout is exceeded.
            </summary>
      <param name="timeout">A timespan representing the timeout period.</param>
      <returns>The future's value.</returns>
      <exception cref="T:System.TimeoutException">thrown if the timeout is exceeded before the value becomes available.</exception>
      <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture`1.AwaitValue(System.TimeSpan)" inheritedFromTypeName="IFuture" exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="P:FlitBit.Core.Parallel.Future`1.SyncObject">
      <summary>
              Gets the future's synchronization object.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Future`1.IsCompleted">
      <summary>
              Indicates whether the wait has completed.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Future`1.IsFaulted">
      <summary>
              Determines if the completion resulted in an error.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Future`1.Exception">
      <summary>
              Gets the exception that caused the fault.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Future`1.Value">
      <summary>
              Gets the future variable's value. Warning! Reading this property
              will block your thread indefinitely or until the future variable
              has been set; whichever comes sooner.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Future`1.WaitHandle">
      <summary>
              Gets a wait handle for the future.
            </summary>
      <getter>
        <requires inheritedFrom="M:FlitBit.Core.Parallel.IFuture.get_WaitHandle" inheritedFromTypeName="IFuture" exception="T:System.ObjectDisposedException" csharp="!this.IsDisposed" vb="Not Me.IsDisposed">!this.IsDisposed</requires>
      </getter>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="T:FlitBit.Core.Parallel.CodeContracts.ContractForIFuture">
      <summary>
              CodeContracts Class for IFuture&lt;&gt;
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.CodeContracts.ContractForIFuture`1">
      <summary>
              CodeContracts Class for IFuture&lt;&gt;
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.Notification">
      <summary>
              Utility for notify
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Notification.ContinueWith(System.IAsyncResult,System.Action)">
      <summary>
              Schedules a continuation action for after an async result
              completes.
            </summary>
      <param name="async">the async result</param>
      <param name="after">the continuation</param>
    </member>
    <member name="P:FlitBit.Core.Parallel.Notification.Instance">
      <summary>
              Accesses the (Lazy) notification instance.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.Reactor`1">
      <summary>
              A parallel reactor is used to efficiently trigger actions in parallel in
              response to items being pushed to the reactor.
            </summary>
      <typeparam name="TItem">item type TItem</typeparam>
    </member>
    <member name="T:FlitBit.Core.Parallel.ReactorBase">
      <summary>
              Base class for Reactor&lt;TItem&gt;
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorBase.DefaultOptions">
      <summary>
              The default options used by reactors when none are given to the constructor.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorBase.IsForegroundThreadBorrowed">
      <summary>
              Indicates whether the foreground thread has been barrowed by the reactor.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.Reactor`1.#ctor(System.Action{FlitBit.Core.Parallel.Reactor{`0},`0})">
      <summary>
              Creates a new instance with the default options.
            </summary>
      <param name="reactor">the reactor's action</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.Reactor`1.#ctor(System.Action{FlitBit.Core.Parallel.Reactor{`0},`0},FlitBit.Core.Parallel.ReactorOptions)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="reactor">the reactor's action</param>
      <param name="options">options</param>
      <requires exception="T:System.ArgumentNullException" csharp="reactor != null" vb="reactor &lt;&gt; Nothing">reactor != null</requires>
      <exception cref="T:System.ArgumentNullException">reactor == null</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Reactor`1.Cancel">
      <summary>
              Stops a reactor. Once stopped a reactor cannot be restarted.
            </summary>
      <returns>the reactor (for chaining)</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.Reactor`1.Push(`0)">
      <summary>
              Pushes a new item to the reactor.
            </summary>
      <param name="item">an item</param>
      <returns>the reactor (for chaining)</returns>
      <requires exception="T:System.InvalidOperationException" csharp="!this.IsCanceled" vb="Not Me.IsCanceled">!this.IsCanceled</requires>
      <exception cref="T:System.InvalidOperationException">IsCanceled</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.Reactor`1.AllowLogEvent(System.Diagnostics.SourceLevels)">
      <summary>
              Determines if a log event is allowed for the levels given.
            </summary>
      <param name="levels" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.Reactor`1.OnLogMessage(System.Diagnostics.TraceEventType,System.String)">
      <summary>
              Occurs when logging messages are created on the reactor.
            </summary>
      <param name="eventType" />
      <param name="message" />
    </member>
    <member name="P:FlitBit.Core.Parallel.Reactor`1.IsActive">
      <summary>
              Indicates whether the reactor is active.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Reactor`1.IsCanceled">
      <summary>
              Indicates whethe the reactor is stopping.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Reactor`1.IsEmpty">
      <summary>
              Determines if the reactor is empty. Empty means there are no items
              that have not already been reacted too.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Reactor`1.IsIdle">
      <summary>
              Indicates whether the reactor is idle.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Reactor`1.IsStopped">
      <summary>
              Indicates whether the reactor is stopped.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.Reactor`1.Options">
      <summary>
              Gets the reactor's options.
            </summary>
    </member>
    <member name="E:FlitBit.Core.Parallel.Reactor`1.UncaughtException">
      <summary>
              Event fired when uncaught exceptions are encountered by the reactor.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.ReactorExceptionArgs">
      <summary>
              EventArgs issued when a reactor encounters an uncaught exception.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ReactorExceptionArgs.#ctor(System.Exception)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="err">the uncaught exception</param>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorExceptionArgs.Rethrow">
      <summary>
              Whether the exception should be rethrown.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorExceptionArgs.UncaughtException">
      <summary>
              The uncaught exception.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.ReactorOptions">
      <summary>
              Options for the Reactor class.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorOptions.DefaultDispatchesPerBorrowedThread">
      <summary>
              Default dispatches per borrowed thread. Used when max parallel depth is exceeded.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorOptions.DefaultMaxDegreeOfParallelism">
      <summary>
              Default max DOP
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorOptions.DefaultMaxParallelDepth">
      <summary>
              Default miximum parallel depth.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ReactorOptions.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ReactorOptions.#ctor(System.Int32)">
      <summary>
              Creates a new instance with a max degree of parallelism.
            </summary>
      <param name="maxDegreeOfParallelism">a max degree of parallelism</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ReactorOptions.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="maxDegreeOfParallelism">a max degree of parallelism</param>
      <param name="yieldBusyReactor">indicates whether to occasionally yield a busy reactor</param>
      <param name="yieldFrequency">indicates yield frequency when yielding a busy reactor</param>
      <param name="maxParallelDepth">maximum parallel depth</param>
      <param name="dispatchesPerSequential">dispatches per borowed thread</param>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="maxDegreeOfParallelism &gt;= 1" vb="maxDegreeOfParallelism &gt;= 1">maxDegreeOfParallelism &gt;= 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxDegreeOfParallelism &lt; 1</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="yieldBusyReactor ⇒ yieldFrequency &gt;= 1" vb="yieldBusyReactor Implies yieldFrequency &gt;= 1">!yieldBusyReactor || yieldFrequency &gt;= 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!yieldBusyReactor || yieldFrequency &lt; 1</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="maxParallelDepth &gt;= 1" vb="maxParallelDepth &gt;= 1">maxParallelDepth &gt;= 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxParallelDepth &lt; 1</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="dispatchesPerSequential &gt;= 1" vb="dispatchesPerSequential &gt;= 1">dispatchesPerSequential &gt;= 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">dispatchesPerSequential &lt; 1</exception>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorOptions.DispatchesPerBorrowedThread">
      <summary>
              Sequential dispatches per borrowed thread.
            </summary>
      <remarks>
              For busy reactors, when borrowing the caller's thread, the number of items to
              process before returning control to the caller.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorOptions.MaxDegreeOfParallelism">
      <summary>
              The reactor's max degree of parallelism. This option controls the maximum number of concurrent threads
              used to react to items pushed to the reactor.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorOptions.MaxParallelDepth">
      <summary>
              Maximum parallel depth.
            </summary>
      <remarks>
              For busy reactors, borrows the callers thread when the maximum parallel depth
              is reached.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorOptions.YieldBusyReactor">
      <summary>
              Whether the reactor yields busy reactor threads. This option can provide better parallelism when the
              entire thread pool is busy.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.ReactorOptions.YieldFrequency">
      <summary>
              Indicates the frequency at which a reactor thread yields.
            </summary>
      <remarks>
              Generally speaking, when a reactor is configured to yield, each thread pool thread will
              react to at most YieldFrequency items before yielding the thread back to the pool.
            </remarks>
    </member>
    <member name="T:FlitBit.Core.Parallel.ReactorState">
      <summary>
              Indicates the Reactor's state.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorState.Idle">
      <summary>
              Indicates the reactor is idle.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorState.Active">
      <summary>
              Indicates the reactor is active.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorState.SuspendSignaled">
      <summary>
              Indicates the reactor is suspending.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorState.Suspended">
      <summary>
              Indicates the reactor is suspended.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorState.StopSignaled">
      <summary>
              Indicates the reactor is stopping.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Parallel.ReactorState.Stopped">
      <summary>
              Indicates the reactor has stopped.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.UncaughtExceptionArgs">
      <summary>
              Event args for uncaught exceptions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.UncaughtExceptionArgs.#ctor(System.Exception)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="e" />
    </member>
    <member name="P:FlitBit.Core.Parallel.UncaughtExceptionArgs.Error">
      <summary>
              The uncaught exception.
            </summary>
    </member>
    <member name="T:FlitBit.Core.PronounceableWordGenerator">
      <summary>
              Generates words that are pronounceable. Original Java code from
              http://www.multicians.org/thvv/gpw.html used for passwords.
              Claimed: This class is free to use without restrictions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.PronounceableWordGenerator.Generate(System.Random,System.Int32,System.Int32,System.Int32)">
      <summary>
              Generates a set of pronounceable fake-words.
            </summary>
      <param name="ran" />
      <param name="wordCount">The number of words to generate.</param>
      <param name="wordLengthMin" />
      <param name="wordLengthMax" />
      <returns>Enumerable words.</returns>
    </member>
    <member name="T:FlitBit.Core.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Chk_ExpectedOffsetIn32BitRange">
      <summary>
              Looks up a localized string similar to bit must be between 0 and 31 inclusive.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Chk_OffsetWouldResultInBufferOverrun">
      <summary>
              Looks up a localized string similar to offset would result in buffer overrun.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_ExceptionOccurredInParallelThread">
      <summary>
              Looks up a localized string similar to An error occured in a parallel thread..
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_index_out_of_range">
      <summary>
              Looks up a localized string similar to index must be zero or greater but less than count.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_ReactorStopped">
      <summary>
              Looks up a localized string similar to reactor has stopped and cannot perform the operation.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_StatusTypeMustBeEnum">
      <summary>
              Looks up a localized string similar to Status&lt;E&gt; requires typeof(E) be an enum.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_AsyncResultAlreadySet">
      <summary>
              Looks up a localized string similar to AsyncResult values are write-once and the value has already been set.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_FutureValueAlreadyPresent">
      <summary>
              Looks up a localized string similar to Future already has a value; futures are write-once..
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_FutureValueNotAvailable">
      <summary>
              Looks up a localized string similar to Future value not yet available.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_TaskStateInvalidExpect">
      <summary>
              Looks up a localized string similar to TaskState is invalid: expected = {0}; actual = {1}.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_TaskUnhandledException">
      <summary>
              Looks up a localized string similar to ParallelTask threw an unhandled exception, see the inner exception for details.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.ResourceClientName">
      <summary>
              Looks up a localized string similar to FlitBit Resource Client v.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.TaskBoundaryName">
      <summary>
              Looks up a localized string similar to TaskBoundary #{0}.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Warn_ErrorWhileDisposingCleanupScope">
      <summary>
              Looks up a localized string similar to uncaught exception while disposing cleanup scope.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Status`1">
      <summary>
              Utility structure for performing and tracking threadsafe state transitions.
            </summary>
      <typeparam name="TEnum">State type E (should be an enum)</typeparam>
    </member>
    <member name="M:FlitBit.Core.Status`1.#ctor(`0)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="initialState">Initial state</param>
    </member>
    <member name="M:FlitBit.Core.Status`1.Equals(System.Object)">
      <summary>
              Tests whether the status is equal to another
            </summary>
      <param name="obj">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.GetHashCode">
      <summary>
              Gets the hashcode.
            </summary>
      <returns>the hashcode</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.ChangeState(`0)">
      <summary>
              Transitions to the given state.
            </summary>
      <param name="value">the target state</param>
    </member>
    <member name="M:FlitBit.Core.Status`1.CompareExchange(`0,`0)">
      <summary>
              Compares the current state to the comparand, if they are equal, replaces the current state with the values
            </summary>
      <param name="value">the value</param>
      <param name="comparand">the comparand</param>
      <returns>the status prior</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.Equals(FlitBit.Core.Status{`0})">
      <summary>
              Tests whethe the status is equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.HasState(`0)">
      <summary>
              Determines if the current state includes the value given.
            </summary>
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Status`1.IsGreaterThan(`0)">
      <summary>
              Determines if the current state is greater than the comparand.
            </summary>
      <param name="comparand">comparand</param>
      <returns>
        <em>true</em> if the current state is greater than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.IsLessThan(`0)">
      <summary>
              Determines if the current state is less than the comparand.
            </summary>
      <param name="comparand">comparand</param>
      <returns>
        <em>true</em> if the current state is less than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SetStateIfGreaterThan(`0,`0)">
      <summary>
              Performs a state transition if the current state compares greater than the <paramref name="comparand" /></summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state</param>
      <returns>
        <em>true</em> if the current state compares greater than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SetStateIfLessThan(`0,`0)">
      <summary>
              Performs a state transition if the current state compares less than the <paramref name="comparand" /></summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state</param>
      <returns>
        <em>true</em> if the current state compares less than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SetStateIfLessThan(`0,`0,System.Action)">
      <summary>
              Performs a state transition if the current state compares less than the <paramref name="comparand" /></summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state</param>
      <param name="action">An action to be performed if the state transition succeeds</param>
      <returns>
        <em>true</em> if the current state compares less than <paramref name="comparand" />; otherwise <em>false</em></returns>
      <requires exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.Status`1.SpinToggleState(`0,`0)">
      <summary>
              Toggles between the toggle state and the desired state - with
              a spin-wait if necessary.
            </summary>
      <param name="desired">desired state</param>
      <param name="toggle">state from which the desired state can toggle</param>
      <returns>
        <em>true</em> if the state transitions to the desired state from the toggle state; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SpinWaitForState(`0,System.Action)">
      <summary>
              Performs a spinwait until the current state equals the target state.
            </summary>
      <param name="targetState">the target state</param>
      <param name="loopAction">An action to perform inside the spin cycle</param>
    </member>
    <member name="M:FlitBit.Core.Status`1.TrySpinWaitForState(`0,System.Func{`0,System.Boolean})">
      <summary>
              Performs a spinwait until the current state equals the target state.
            </summary>
      <param name="targetState">the target state</param>
      <param name="loopAction">
              An action to perform inside the spin cycle;
              waiting continues until either the target state is reached or the loop
              action returns false.
            </param>
      <returns>
        <em>true</em> if the target state was reached; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.TryTransition(`0,`0)">
      <summary>
              Tries to transition the state
            </summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state must match current state</param>
      <returns>
        <em>true</em> if the current state matches <paramref name="comparand" /> and the state is transitioned to
              <paramref name="value" />
              ; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.TryTransition(`0,`0[])">
      <summary>
              Tries to transition the state.
            </summary>
      <param name="value">the target state</param>
      <param name="comparand">one or more comparands</param>
      <returns>
              true if the current state matches one of the comparands and is transitioned to <paramref name="value" />; otherwise false
            </returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.TryTransition(`0,`0,System.Action)">
      <summary>
              Tries to transition the state. Upon success executes the action given.
            </summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state must match current state</param>
      <param name="action">action to perform if the state transition is successful</param>
      <returns>
        <em>true</em> if the current state matches <paramref name="comparand" /> and the state is transitioned to
              <paramref name="value" />
              ; otherwise <em>false</em></returns>
      <requires exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Equality(FlitBit.Core.Status{`0},FlitBit.Core.Status{`0})">
      <summary>
              Specialized == operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Equality(FlitBit.Core.Status{`0},`0)">
      <summary>
              Specialized == operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Equality(`0,FlitBit.Core.Status{`0})">
      <summary>
              Specialized == operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Inequality(FlitBit.Core.Status{`0},FlitBit.Core.Status{`0})">
      <summary>
              Specialized != operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are not equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Inequality(FlitBit.Core.Status{`0},`0)">
      <summary>
              Specialized != operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are not equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Inequality(`0,FlitBit.Core.Status{`0})">
      <summary>
              Specialized != operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are not equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.ToObject(FlitBit.Core.Status{`0})">
      <summary>
              Converts Status&lt;E&gt; to E
            </summary>
      <param name="s">the status</param>
      <returns>the equivalent E</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.ToStatus(`0)">
      <summary>
              Converts E to Status&lt;E&gt;
            </summary>
      <param name="s">the value</param>
      <returns>the equivalent Status&lt;E&gt;</returns>
    </member>
    <member name="P:FlitBit.Core.Status`1.CurrentState">
      <summary>
              Accesses the current state.
            </summary>
    </member>
    <member name="T:FlitBit.Core.TypeLocks">
      <summary>
              Utility class for locks used on types.
            </summary>
    </member>
    <member name="M:FlitBit.Core.TypeLocks.GetKeyForType(System.Type)">
      <summary>
              Gets a key for a type suitable for representing the type as a hashtable
              or dictionary key without pinning the type and its assembly into memory.
            </summary>
      <param name="type" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">type == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.TypeLocks.GetLockForType(System.Type)">
      <summary>
              Gets a lock for a type suitable for synchronizing activity on the type
              without blocking other activity in the VM.
            </summary>
      <param name="type" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">type == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.Util">
      <summary>
              Utility class containing utility functions and extensions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Util.Dispose``1(``0@)">
      <summary>
              Disposes an instance if it is disposable and sets the reference variable to null.
            </summary>
      <typeparam name="T">typeof item T</typeparam>
      <param name="item">reference to an item to be disposed.</param>
      <returns>
        <em>true</em> if the item is disposed as a result of the call; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1Hash(System.String)">
      <summary>
              Gets an SHA1 hashcode for the value given, using the default UTF8 encoding.
            </summary>
      <param name="value" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1Hash(System.String,System.Text.Encoding)">
      <summary>
              Gets an SHA1 hashcode for the value given.
            </summary>
      <param name="value" />
      <param name="enc" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1HashAndConvertToBase64(System.String)">
      <summary>
              Gets an SHA1 hashcode for the value given and converts it to Base64, using the default UTF8 encoding.
            </summary>
      <param name="value" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1HashAndConvertToBase64(System.String,System.Text.Encoding)">
      <summary>
              Gets an SHA1 hashcode for the value given and converts it to Base64.
            </summary>
      <param name="value" />
      <param name="enc" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.InternIt(System.String)">
      <summary>
              Interns a string if it is not already interned.
            </summary>
      <param name="value">the target string</param>
      <returns>the value string interned</returns>
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.LazyInitializeWithLock``1(``0@,System.Object)">
      <summary>
              Initializes a referenced variable if it is not already initialized.
            </summary>
      <typeparam name="T">variable type T</typeparam>
      <param name="variable">reference to the variable being initialized</param>
      <param name="lck">an object used as a lock if initialization is necessary</param>
      <requires exception="T:System.ArgumentNullException" csharp="lck != null" vb="lck &lt;&gt; Nothing">lck != null</requires>
      <exception cref="T:System.ArgumentNullException">lck == null</exception>
    </member>
    <member name="M:FlitBit.Core.Util.LazyInitializeWithLock``1(``0@,System.Object,System.Func{``0})">
      <summary>
              Initializes a referenced variable if it is not already initialized. Uses
              the <paramref name="factory" /> to create the instance if necessary.
            </summary>
      <typeparam name="T">variable type T</typeparam>
      <param name="variable">reference to the variable being initialized</param>
      <param name="lck">an object used as a lock if initialization is necessary</param>
      <param name="factory">factory delegate</param>
      <returns>the value of the variable, after the lazy initailize</returns>
      <requires exception="T:System.ArgumentNullException" csharp="lck != null" vb="lck &lt;&gt; Nothing">lck != null</requires>
      <exception cref="T:System.ArgumentNullException">lck == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
      <exception cref="T:System.ArgumentNullException">factory == null</exception>
    </member>
    <member name="M:FlitBit.Core.Util.NonBlockingLazyInitializeVolatile``1(``0@,System.Func{``0})">
      <summary>
              Initializes a variable if it doesn't already have a value. This method is
              thread-safe and non-blocking.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="value">reference to the value</param>
      <param name="factory">function that creates the instance if it doesn't have a value</param>
      <returns>the instance</returns>
      <requires csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
    </member>
    <member name="M:FlitBit.Core.Util.NonBlockingLazyInitializeVolatile``1(``0@)">
      <summary>
              Initializes a variable if it doesn't already have a value. This method is
              thread-safe and non-blocking.
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="M:FlitBit.Core.Util.VolatileRead``1(``0@)">
      <summary>
              Reads the referenced value within a full-fence.
            </summary>
      <typeparam name="T" />
      <param name="reference" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Util.VolatileWrite``1(``0@,``0)">
      <summary>
              Writes a value to a reference within a full-fence.
            </summary>
      <typeparam name="T" />
      <param name="reference" />
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Util.MakeReliableLockFromString(System.String)">
      <summary>
              Interns a string if it is not already interned.
            </summary>
      <param name="value">the target string</param>
      <returns>the value string interned</returns>
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.WeakReference`1">
      <summary>
              Strongly typed weak reference.
            </summary>
      <typeparam name="T">referenced type T</typeparam>
    </member>
    <member name="M:FlitBit.Core.WeakReference`1.#ctor(`0)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="target">a reference target.</param>
    </member>
    <member name="M:FlitBit.Core.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Creates a new instance (from serialization)
            </summary>
      <param name="info">serialization info</param>
      <param name="context">serialization context</param>
    </member>
    <member name="P:FlitBit.Core.WeakReference`1.StrongTarget">
      <summary>
              Gets the referenced target as type T.
            </summary>
    </member>
    <member name="T:FlitBit.Core.WeakReferenceExtensions">
      <summary>
              Extends the weak reference type.
            </summary>
    </member>
    <member name="M:FlitBit.Core.WeakReferenceExtensions.TryGetStrongTarget``1(System.WeakReference,``0@)">
      <summary>
              Tries to get the target of the reference.
            </summary>
      <typeparam name="T">type T of the referenced object</typeparam>
      <param name="weakRef">the target reference</param>
      <param name="target">reference to a variable that will recieve the target if successful</param>
      <returns>
        <em>true</em> if the reference is alive and has a valid value of type T; otherwise <em>false</em></returns>
      <exception cref="T:System.InvalidCastException">thrown if the target of the reference cannot be cast to type T</exception>
    </member>
    <member name="T:FlitBit.Core.Xml.XDynamic">
      <summary>
              Static class for creating dynamic objects over XML
            </summary>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.Parse(System.String,System.Boolean)">
      <summary>
              Parses the input text and returns a dynamic object.
            </summary>
      <param name="text">source xml text</param>
      <param name="includeRootObject">whether or not the root object is included in the structure of the resulting dynamic</param>
      <returns>a dynamic object shaped like the input xml</returns>
      <requires csharp="text != null" vb="text &lt;&gt; Nothing">text != null</requires>
      <requires csharp="text.Length &gt; 0" vb="text.Length &gt; 0">text.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.Parse(System.String)">
      <summary>
              Parses the input text and returns a dynamic object.
            </summary>
      <param name="text">source xml text</param>
      <returns>a dynamic object shaped like the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.ToDynamic(System.Xml.Linq.XElement)">
      <summary>
              Creates an object over the XElement given.
            </summary>
      <param name="elm">the source element</param>
      <returns>an object shaped like the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.AddAttributesToDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Xml.Linq.XElement)">
      <summary>
              Adds attributes from an element into the dictionary given.
            </summary>
      <param name="expando">target dictionary</param>
      <param name="elm">source element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.AddElementsToDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Xml.Linq.XElement)">
      <summary>
              Adds child elements from an element into the dictionary given.
            </summary>
      <param name="expando">target dictionary</param>
      <param name="elm">source element</param>
    </member>
    <member name="T:FlitBit.Core.Xml.XElementExtensions">
      <summary>
              Extensions for working with XElement and XML
            </summary>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadBooleanOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadByteOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named byte value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadBytesOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named byte array value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadCharOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named char value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadDecimalOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named decimal value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadDoubleOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named double value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadGuidOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Guid value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadInt16OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Int16 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadInt32OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Int32 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadInt64OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Int64 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Boolean@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Boolean@,System.Boolean)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Boolean@,System.Func{System.Boolean})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Byte@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Byte@,System.Byte)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Byte@,System.Func{System.Byte})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Char@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Char@,System.Char)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Char@,System.Func{System.Char})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.DateTime@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.DateTime@,System.DateTime)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.DateTime@,System.Func{System.DateTime})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Decimal@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Decimal@,System.Decimal)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Decimal@,System.Func{System.Decimal})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Double@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Double@,System.Double)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Double@,System.Func{System.Double})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int16@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int16@,System.Int16)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int16@,System.Func{System.Int16})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int32@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int32@,System.Int32)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int32@,System.Func{System.Int32})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int64@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int64@,System.Int64)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int64@,System.Func{System.Int64})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault``1(System.Xml.Linq.XElement,System.String,``0@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault``1(System.Xml.Linq.XElement,System.String,``0@,``0)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault``1(System.Xml.Linq.XElement,System.String,``0@,System.Func{``0})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.SByte@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.SByte@,System.SByte)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.SByte@,System.Func{System.SByte})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Single@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Single@,System.Single)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Single@,System.Func{System.Single})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.String@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.String@,System.String)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.String@,System.Func{System.String})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt16@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt16@,System.UInt16)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt16@,System.Func{System.UInt16})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt32@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt32@,System.UInt32)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt32@,System.Func{System.UInt32})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt64@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt64@,System.UInt64)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt64@,System.Func{System.UInt64})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefaultAsEnum``1(System.Xml.Linq.XElement,System.String,``0@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefaultAsEnum``1(System.Xml.Linq.XElement,System.String,``0@,``0)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefaultAsEnum``1(System.Xml.Linq.XElement,System.String,``0@,System.Func{``0})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadSByteOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named SByte value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadSingleOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named single value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadStringOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named String value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadUInt16OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named UInt16 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadUInt32OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named UInt32 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadUInt64OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named UInt64 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ToDynamic(System.Xml.Linq.XElement)">
      <summary>
              Converts an XElement into a dynamic XML object.
            </summary>
      <param name="xml">the source xml element</param>
      <returns>a dynamic object shaped according to the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Boolean@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Byte@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Char@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.DateTime@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Decimal@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Double@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Int16@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Int32@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Int64@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue``1(System.Xml.Linq.XContainer,System.String,``0@)">
      <summary>
              Tries to read a named value from an xml container.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.SByte@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Single@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.String@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.UInt16@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.UInt32@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.UInt64@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValueAsEnum``1(System.Xml.Linq.XElement,System.String,``0@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <requires description="typeof(T) must be an enum" csharp="typeof(T).IsEnum" vb="typeof(T).IsEnum">typeof(T).IsEnum</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.XmlToDynamic(System.String)">
      <summary>
              Converts a string into a dynamic XML object.
            </summary>
      <param name="text">the source xml</param>
      <returns>a dynamic object shaped according to the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ExecuteHttpVerb(System.Net.HttpWebRequest,System.String,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
      <exception cref="T:System.ArgumentNullException">after == null</exception>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ExecuteHttpVerbWithPostBody(System.Net.HttpWebRequest,System.Byte[],System.String,System.String,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
      <exception cref="T:System.ArgumentNullException">after == null</exception>
    </member>
    <member name="M:FlitBit.Core.Collections.EnumerableKeyValuePairs.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.MarkCompleted(System.Boolean)">
      <requires exception="T:System.InvalidOperationException" csharp="!this.IsCompleted" vb="Not Me.IsCompleted">!this.IsCompleted</requires>
      <exception cref="T:System.InvalidOperationException">IsCompleted</exception>
    </member>
    <member name="M:FlitBit.Core.Parallel.AsyncResult.MarkException(System.Exception,System.Boolean)">
      <requires exception="T:System.InvalidOperationException" csharp="!this.IsCompleted" vb="Not Me.IsCompleted">!this.IsCompleted</requires>
      <exception cref="T:System.InvalidOperationException">IsCompleted</exception>
    </member>
  </members>
</doc>