<?xml version="1.0"?>
<doc>
  <assembly>
    <name>FlitBit.IoC</name>
  </assembly>
  <members>
    <member name="T:FlitBit.IoC.Constructors.CommandBinding`1">
      <summary>
              Base class for command bindings.
            </summary>
      <typeparam name="T">target type T</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.CommandBinding`1.#ctor(FlitBit.IoC.Constructors.ConstructorAdapter{`0})">
      <summary>
              Creates a new instance.
            </summary>
      <param name="adapter">A constructor adapter for type T</param>
    </member>
    <member name="M:FlitBit.IoC.Constructors.CommandBinding`1.Execute(FlitBit.IoC.IContainer,System.String)">
      <summary>
              Executes the constructor adapter and returns the resulting instance.
            </summary>
      <param name="container">scoping container</param>
      <param name="name">the registered name or null</param>
      <returns>the resulting instance</returns>
    </member>
    <member name="P:FlitBit.IoC.Constructors.CommandBinding`1.Adapter">
      <summary>
              Gets the constructor adapter for target type T
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Constructors.ConstructorAdapter`2">
      <summary>
              Adapter for constructors defined on concrete type C of type T
            </summary>
      <typeparam name="T">type T</typeparam>
      <typeparam name="TConcrete">concrete type C</typeparam>
      <summary>
              Adapter for constructors defined on concrete type of type T
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Constructors.ConstructorAdapter`1">
      <summary>
              Adapter for constructors defined on type T
            </summary>
      <typeparam name="T">type T</typeparam>
      <summary>
              Adapter for constructors defined on type T
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorAdapter`1.Execute(FlitBit.IoC.IContainer,System.String,System.Object[])">
      <summary>
              Executes the constructor and returns the resulting instance.
            </summary>
      <param name="container">scoping container</param>
      <param name="name">the registered name or null</param>
      <param name="parameters">parameters intended for the new instance</param>
      <returns>a new instance</returns>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorAdapter`1.GetConstructorAdapterByOrdinal(System.Int32,System.Reflection.ConstructorInfo)">
      <summary>
              Compiles a constructor adapter for the given constructor.
            </summary>
      <param name="ordinal">the ordinal position of the constructor among constructors defined on type T</param>
      <param name="ci">constructor info</param>
      <returns>the compiled constructor adapter type</returns>
      <requires csharp="ci != (System.Reflection.ConstructorInfo)null" vb="ci &lt;&gt; ((System.Reflection.ConstructorInfo)Nothing) ">ci != (System.Reflection.ConstructorInfo)null</requires>
      <ensures csharp="result != (System.Type)null" vb="result &lt;&gt; ((System.Type)Nothing) ">result != (System.Type)null</ensures>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorAdapter`2.GetConstructorAdapterByOrdinal(System.Int32,System.Reflection.ConstructorInfo)">
      <summary>
              Compiles a constructor adapter for the given constructor.
            </summary>
      <param name="ordinal">the ordinal position of the constructor among constructors defined on type T</param>
      <param name="ci">constructor info</param>
      <returns>the compiled constructor adapter type</returns>
      <ensures csharp="result != (System.Type)null" vb="result &lt;&gt; ((System.Type)Nothing) ">result != (System.Type)null</ensures>
    </member>
    <member name="T:FlitBit.IoC.Constructors.ConstructorCommand`1">
      <summary>
              Base constructor command; matches incomming parameters to the most suitable
              constructor declared on the target type.
            </summary>
      <typeparam name="T">target type T</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorCommand`1.TryMatchAndBind(FlitBit.IoC.Param[],FlitBit.IoC.Constructors.CommandBinding{`0}@)">
      <summary>
              Tries to match supplied params to a constructor and provides a command binding.
            </summary>
      <param name="parameters">the supplied parameters</param>
      <param name="binding">variable to hold the binding upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="P:FlitBit.IoC.Constructors.ConstructorCommand`1.BoundToSuppliedDefaults">
      <summary>
              Indicates whether the command is bound to supplied defaults.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Constructors.ConstructorCommand`1.ParameterCount">
      <summary>
              Gets the parameter count.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Constructors.ConstructorCommand`2">
      <summary>
              Default implementation of the constructor command type.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TConcrete">concrete type C</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorCommand`2.#ctor(System.Reflection.ConstructorInfo,FlitBit.IoC.Param[],System.Int32)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="ci">reflected constructor info</param>
      <param name="defaults">default params supplied during registration</param>
      <param name="ordinal">ordinal position of the constructor among constructors for the concrete type</param>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorCommand`2.TryMatchAndBind(FlitBit.IoC.Param[],FlitBit.IoC.Constructors.CommandBinding{`0}@)">
      <summary>
              Tries to match supplied params to a constructor and provides a command binding.
            </summary>
      <param name="parameters">the supplied parameters</param>
      <param name="binding">variable to hold the binding upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="P:FlitBit.IoC.Constructors.ConstructorCommand`2.BoundToSuppliedDefaults">
      <summary>
              Indicates whether the command is bound to supplied defaults.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Constructors.ConstructorCommand`2.ParameterCount">
      <summary>
              Gets the parameter count.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Constructors.ConstructorSet`2">
      <summary>
              Gets a contructor set for a type.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TConcrete">concrete type C</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.ConstructorSet`2.#ctor(FlitBit.IoC.Param[])">
      <summary>
              Creates a new instance.
            </summary>
      <param name="parameters" />
    </member>
    <member name="T:FlitBit.IoC.Constructors.DefaultConstructorAdapter`1">
      <summary>
              Constructor adapter for types that have a default constructor.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:FlitBit.IoC.Constructors.DefaultConstructorAdapter`1.Execute(FlitBit.IoC.IContainer,System.String,System.Object[])">
      <summary>
              Executes the constructor and returns the resulting instance.
            </summary>
      <param name="container">scoping container</param>
      <param name="name">the registered name or null</param>
      <param name="parameters">parameters intended for the new instance</param>
      <returns>a new instance</returns>
    </member>
    <member name="T:FlitBit.IoC.Constructors.DefaultConstructorAdapter`2">
      <summary>
              Constructor adapter for types that have a default constructor.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TConcrete">concrete type C</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.DefaultConstructorAdapter`2.Execute(FlitBit.IoC.IContainer,System.String,System.Object[])">
      <summary>
              Executes the constructor and returns the resulting instance.
            </summary>
      <param name="container">scoping container</param>
      <param name="name">the registered name or null</param>
      <param name="parameters">parameters intended for the new instance</param>
      <returns>a new instance</returns>
    </member>
    <member name="T:FlitBit.IoC.Constructors.FactoryConstructorAdapter`1">
      <summary>
              Factory constructor adapter.
            </summary>
      <typeparam name="T">target type T</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.FactoryConstructorAdapter`1.Execute(FlitBit.IoC.IContainer,System.String,System.Object[])">
      <summary>
              Executes the constructor and returns the resulting instance.
            </summary>
      <param name="container">scoping container</param>
      <param name="name">the registered name or null</param>
      <param name="parameters">parameters intended for the new instance</param>
      <returns>a new instance</returns>
    </member>
    <member name="T:FlitBit.IoC.Constructors.FactoryConstructorAdapter`2">
      <summary>
              Factory constructor adapter.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TConcrete">concrete type C</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Constructors.FactoryConstructorAdapter`2.Execute(FlitBit.IoC.IContainer,System.String,System.Object[])">
      <summary>
              Executes the constructor and returns the resulting instance.
            </summary>
      <param name="container">scoping container</param>
      <param name="name">the registered name or null</param>
      <param name="parameters">parameters intended for the new instance</param>
      <returns>a new instance</returns>
    </member>
    <member name="T:FlitBit.IoC.Container">
      <summary>
              Utility class for working with containers.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Container.IdentifyTenantAsLogicalRoot">
      <summary>
              Identifies the current tenant's container as the logical root container.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Container.Current">
      <summary>
              Gets the container assigned to the current thread.
            </summary>
      <getter>
        <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:FlitBit.IoC.Container.LogicalRoot">
      <summary>
              Gets the logical root container.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Container.Root">
      <summary>
              Gets the root container.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Factory.FactoryProvider">
      <summary>
              Factory provider implementation that returns the current IContainer.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Meta.RegistrationBehaviors">
      <summary>
              Indicates registration behavior.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.None">
      <summary>
              None; empty.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.Default">
      <summary>
              Indicates the target is the default implementation.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.Named">
      <summary>
              Indicates the target is a named implementation.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.OverrideDefault">
      <summary>
              Indicates the target is intended to override
              the default implementation.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.OverrideNamed">
      <summary>
              Indicates the target is intended to override
              a named implementation.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.IfNoneOther">
      <summary>
              Indicates the target is to be the registered
              instance if no other registrations exist.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Meta.RegistrationBehaviors.DefaultOrOverrideDefault">
      <summary>
              Indicates the target is either the default instance
              or if a default exists; target overrides the default.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Meta.ContainerRegisterAttribute">
      <summary>
              Indicates that the target should be registered with the
              IoC container upon assembly wireup.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Meta.ContainerRegisterAttribute.#ctor">
      <summary>
              Creates a new instance; used the implemented type can be inferred from a single
              superclass or interface implementation.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Meta.ContainerRegisterAttribute.#ctor(System.Type,FlitBit.IoC.Meta.RegistrationBehaviors)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="registerFor">
              indicates the type for which the target will become
              a registered implementation.
            </param>
      <param name="behaviors">registration behaviors</param>
    </member>
    <member name="M:FlitBit.IoC.Meta.ContainerRegisterAttribute.#ctor(System.Type,FlitBit.IoC.Meta.RegistrationBehaviors,System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="registerFor">
              indicates the type for which the target will become
              a registered implementation.
            </param>
      <param name="behaviors">registration behaviors</param>
      <param name="name">the registered implementation's name</param>
    </member>
    <member name="M:FlitBit.IoC.Meta.ContainerRegisterAttribute.PerformTask(FlitBit.Wireup.IWireupCoordinator)">
      <summary>
              Performs the wireup task.
            </summary>
      <param name="coordinator" />
    </member>
    <member name="P:FlitBit.IoC.Meta.ContainerRegisterAttribute.Behaviors">
      <summary>
              Gets the registration behaviors.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Meta.ContainerRegisterAttribute.Name">
      <summary>
              Gets the named implementation's name; otherwise null.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Meta.ContainerRegisterAttribute.RegistratedForType">
      <summary>
              Gets the type for which the target type is registered.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Meta.ContainerRegisterAttribute.ScopeBehavior">
      <summary>
              Indicates scope behavior for instances of the implementation type.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.IContainer">
      <summary>
              Container interface.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.IContainer.EnsureCache``2(``0,System.Func{``1})">
      <summary>
              Ensures a cache is registered with the context and returns
              that cache.
            </summary>
      <typeparam name="TKey">Registration key type K</typeparam>
      <typeparam name="TCache">Cache type C</typeparam>
      <param name="key">registration key</param>
      <param name="factory">
              factory method that will be used to create a new cache if one is not
              already present.
            </param>
      <returns>a cache</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.EnsureCache``2(``0)">
      <summary>
              Ensures a cache is registered with the context and returns
              that cache.
            </summary>
      <typeparam name="TKey">Registration key type K</typeparam>
      <typeparam name="TCache">Cache type C</typeparam>
      <param name="key">registration key</param>
      <returns>a cache</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.MakeChildContainer(FlitBit.IoC.CreationContextOptions)">
      <summary>
              Makes a child container from the current container.
            </summary>
      <param name="options">options </param>
      <returns />
    </member>
    <member name="M:FlitBit.IoC.IContainer.New``1(FlitBit.IoC.LifespanTracking)">
      <summary>
              Resolves type T to an instance according to it's registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">
              Lifespan tracking used for the instance
              if it is newly created.
            </param>
      <returns>an instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.NewImplementationOf``1(FlitBit.IoC.LifespanTracking,System.Type)">
      <summary>
              Resolves a specific implementation of type T according to the implementation's registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">
              Lifespan tracking used for the instance
              if it is newly created.
            </param>
      <param name="subtype" />
      <returns>an instance of the implementation type</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.NewNamed``1(FlitBit.IoC.LifespanTracking,System.String)">
      <summary>
              Resolves type T to an instance according to a named registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">
              Lifespan tracking used for the instance
              if it is newly created.
            </param>
      <param name="name">the name</param>
      <returns>an instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.NewNamedWithParams``1(FlitBit.IoC.LifespanTracking,System.String,FlitBit.IoC.Param[])">
      <summary>
              Resolves type T to an instance according to a named registration, utilizing the
              parameters given if the instance must be newly created.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">
              Lifespan tracking used for the instance
              if it is newly created.
            </param>
      <param name="name">the name</param>
      <param name="parameters">
              Initialization parameters whose values are used
              if an instance must be newly created.
            </param>
      <returns>an instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.NewUntyped(FlitBit.IoC.LifespanTracking,System.Type)">
      <summary>
              Creates a new instance of the target type.
            </summary>
      <param name="tracking" />
      <param name="targetType" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.IContainer.NewWithParams``1(FlitBit.IoC.LifespanTracking,FlitBit.IoC.Param[])">
      <summary>
              Resolves type T to an instance according to it's registration, utilizing the
              parameters given if the instance must be newly created.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">
              Lifespan tracking used for the instance
              if it is newly created.
            </param>
      <param name="parameters">
              Initialization parameters whose values are used
              if an instance must be newly created.
            </param>
      <returns>an instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainer.NotifyObserversOfCreationEvent``1(System.Type,``0,System.String,FlitBit.IoC.CreationEventKind)">
      <summary>
              Notifies observers of type T that a creation event occurred.
            </summary>
      <typeparam name="T" />
      <param name="requestedType" />
      <param name="instance" />
      <param name="name" />
      <param name="evt" />
    </member>
    <member name="M:FlitBit.IoC.IContainer.ShareContainer">
      <summary>
              Prepares the container for being shared in multiple threads.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.IoC.IContainer.Subscribe``1(System.Action{System.Type,``0,System.String,FlitBit.IoC.CreationEventKind})">
      <summary>
              Creates a subscription to creation events against type T.
            </summary>
      <typeparam name="T">subscription target type T</typeparam>
      <param name="observer">An action that will be called upon creation events against type T</param>
    </member>
    <member name="M:FlitBit.IoC.IContainer.TryGetCache``2(``0,``1@)">
      <summary>
              Tries to get a cache from the creation context.
            </summary>
      <typeparam name="TKey">Registration key type K</typeparam>
      <typeparam name="TCache">Cache type C</typeparam>
      <param name="key">registration key</param>
      <param name="cache">output variable where the cache will be returned upon success</param>
      <returns>true if the cache was returned; otherwise false.</returns>
    </member>
    <member name="P:FlitBit.IoC.IContainer.IsRoot">
      <summary>
              Indicates whether the container is the root.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.IContainer.IsTenant">
      <summary>
              Indicates whether the container is within a tenant scope.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.IContainer.Key">
      <summary>
              Gets the container's unique ID.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.IContainer.Registry">
      <summary>
              Gets the container's registry.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.IContainer.Scope">
      <summary>
              Gets the cleanup scope for the context.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.IContainer.TenantID">
      <summary>
              Gets the current tenant identifier if the container is
              within a tentant scope; otherwise null.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.IRootContainer">
      <summary>
              Interface for root containers.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.IRootContainer.RegisterMultiTenant``1">
      <summary>
              Registers a multi-tenant resolver with the container.
            </summary>
      <typeparam name="TTenantResolver">tenant resolver type TTenantResolver</typeparam>
      <returns>A type registration for the tenant resolver</returns>
    </member>
    <member name="M:FlitBit.IoC.IRootContainer.RegisterMultiTenant``1(System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],``0})">
      <summary>
              Registers a multi-tenant resolver with the container.
            </summary>
      <typeparam name="TTenantResolver">tenant resolver type TTenantResolver</typeparam>
      <param name="factory">factory that will provide the tenant resolver instances</param>
      <returns>A type registration for the tenant resolver</returns>
    </member>
    <member name="M:FlitBit.IoC.IRootContainer.RegisterTenant(System.Object)">
      <summary>
              Registers a tenant ID returning the tenant specific root container.
            </summary>
      <param name="id">tenant ID</param>
      <returns>the tenant specific root container</returns>
    </member>
    <member name="M:FlitBit.IoC.IRootContainer.ResolveCurrentTenant">
      <summary>
              Resolves the current tenant and returns the tenant specific root container.
            </summary>
      <returns>the tenant specific root container</returns>
    </member>
    <member name="M:FlitBit.IoC.IRootContainer.ResolveTenantByID(System.Object)">
      <summary>
              Resolves the tenant by ID and returns the tenant specific root container.
            </summary>
      <param name="id">the tenant ID</param>
      <returns>the tenant specific root container</returns>
    </member>
    <member name="M:FlitBit.IoC.IRootContainer.TryResolveTenant(System.Object@)">
      <summary>
              Tries to resolve a tenant ID.
            </summary>
      <param name="id">variable to hold the tenant ID upon success</param>
      <returns>true if the tenant is resolved; otherwise false</returns>
    </member>
    <member name="P:FlitBit.IoC.IRootContainer.SupportsMultipleTenants">
      <summary>
              Indicates whether the container has multi-tenant support.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Create">
      <summary>
              Utility class for working with containers.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Create.AsIf``1(System.Object)">
      <summary>
              Creates an interface proxy type T over the source object. (If it looks like a duck, etc, etc.)
            </summary>
      <typeparam name="T">interface type T</typeparam>
      <param name="source">the source</param>
      <returns>an interface proxy (duck type) over the source</returns>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
      <requires exception="T:System.ArgumentException" csharp="typeof(T).IsInterface" vb="typeof(T).IsInterface">typeof(T).IsInterface</requires>
      <exception cref="T:System.ArgumentException">!(typeof(T).IsInterface)</exception>
    </member>
    <member name="M:FlitBit.IoC.Create.Mutate``2(``1,System.Func{FlitBit.IoC.IContainer,``0,``0})">
      <summary>
              Creates a new instance of type T as a mutation of type S, using the provided mutator.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="source">a source object</param>
      <param name="mutator">a mutator function</param>
      <returns>an instance of type T, initialized from the source object, mutated using the provided mutator.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="mutator != null" vb="mutator &lt;&gt; Nothing">mutator != null</requires>
      <exception cref="T:System.ArgumentNullException">mutator == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Create.Mutate``2(``1,System.Func{FlitBit.IoC.IContainer,``0,``0},FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T as a mutation of type S, using the provided mutator.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="source">a source object</param>
      <param name="mutator">a mutator function</param>
      <param name="tracking">lifespan tracking for the new instance</param>
      <returns>an instance of type T, initialized from the source object, mutated using the provided mutator.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="mutator != null" vb="mutator &lt;&gt; Nothing">mutator != null</requires>
      <exception cref="T:System.ArgumentNullException">mutator == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Create.New``1">
      <summary>
              Resolves an instance of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>a resolved instance of type T</returns>
      <remarks>
              If type T implements IDisposable it is the caller's
              responsibility to ensure that the Dispose method is called
              at the appropriate time. To change this behavior call the
              overloaded New method and supply an alternate LifespanTracking value.
            </remarks>
    </member>
    <member name="M:FlitBit.IoC.Create.New``1(FlitBit.IoC.LifespanTracking)">
      <summary>
              Resolves an instance of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">lifespan tracking</param>
      <returns>a resolved instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.New``1(System.Type)">
      <summary>
              Resolves a specific implementation of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="impl">implementation type</param>
      <returns>a resolved instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.New``1(FlitBit.IoC.LifespanTracking,System.Type)">
      <summary>
              Resolves a specific implementation of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">lifespan tracking</param>
      <param name="impl">implementation type</param>
      <returns>a resolved instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.NewContainer">
      <summary>
              Creates a new container scoped by the current container.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.IoC.Create.NewContainer(FlitBit.IoC.CreationContextOptions)">
      <summary>
              Creates a new container scoped by the current container.
            </summary>
      <param name="options">creation context options</param>
      <returns />
      <see cref="T:FlitBit.IoC.CreationContextOptions" />
    </member>
    <member name="M:FlitBit.IoC.Create.NewCopy``2(``1)">
      <summary>
              Creates a new instance of type T, initialized from the provided source.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="source">a source object</param>
      <returns>an instance of type T, initialized from the source object.</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.NewCopy``2(``1,FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T, initialized from the provided source.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="source">a source object</param>
      <param name="tracking">tracking</param>
      <returns>an instance of type T, initialized from the source object.</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.NewInit``1">
      <summary>
              Creates a new instance of type T for initialization.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.Create.NewInit``1(FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T for initialization.
            </summary>
      <typeparam name="T" />
      <param name="tracking" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.Create.NewInit``1(System.Func{FlitBit.IoC.IContainer,``0,``0})">
      <summary>
              Creates a new instance of type T and initializes it using the provided initializer.
            </summary>
      <typeparam name="T" />
      <param name="initializer" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="initializer != null" vb="initializer &lt;&gt; Nothing">initializer != null</requires>
      <exception cref="T:System.ArgumentNullException">initializer == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Create.NewInit``1(System.Func{FlitBit.IoC.IContainer,``0,``0},FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T and initializes it using the provided initializer.
            </summary>
      <typeparam name="T" />
      <param name="initializer" />
      <param name="tracking" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="initializer != null" vb="initializer &lt;&gt; Nothing">initializer != null</requires>
      <exception cref="T:System.ArgumentNullException">initializer == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Create.NewNamed``1(System.String)">
      <summary>
              Resolves a named instance of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="name">the instance's name</param>
      <returns>a resolved instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.NewNamed``1(System.String,FlitBit.IoC.LifespanTracking)">
      <summary>
              Resolves a named instance of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="name">the instance's name</param>
      <param name="tracking">lifespan tracking</param>
      <returns>a resolved instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.NewWithParams``1(FlitBit.IoC.LifespanTracking,FlitBit.IoC.Param[])">
      <summary>
              Resolves an instance of type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="tracking">lifespan tracking</param>
      <param name="parameters">the parameters</param>
      <returns>a resolved instance of type T</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.SharedOrNewContainer">
      <summary>
              Gets a container with its own scope; either an existing
              container that is not root or a new child container.
            </summary>
      <returns>a container</returns>
    </member>
    <member name="M:FlitBit.IoC.Create.TenantContainer">
      <summary>
              Creates a tenant container.
            </summary>
      <returns />
    </member>
    <member name="T:FlitBit.IoC.BasicDuck">
      <summary>
              Used by the framework for duck typing dynamic objects.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.BasicDuck.#ctor(System.Object)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="source" />
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:FlitBit.IoC.BasicDuck.MakeGetMemberBinder(System.String)">
      <summary>
              Gets a binder for a member property.
            </summary>
      <param name="member" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.BasicDuck.MakeSetMemberBinder(System.String)">
      <summary>
              Gets a binder for a member property.
            </summary>
      <param name="member" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.BasicDuck.CastDuckTarget``1">
      <summary>
              Casts the duck type as target type T
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.BasicDuck.GetMember(System.String)">
      <summary>
              Gets a member by name.
            </summary>
      <param name="member" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.BasicDuck.SetMember(System.String,System.Object)">
      <summary>
              Sets the member by name.
            </summary>
      <param name="member" />
      <param name="val" />
    </member>
    <member name="P:FlitBit.IoC.BasicDuck.DuckTarget">
      <summary>
              Gets the source object that has been duck typed.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.BasicDuckGetMemberBinder">
      <summary>
              Helper class for getting duck type'd members.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.BasicDuckGetMemberBinder.#ctor(System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="name" />
    </member>
    <member name="M:FlitBit.IoC.BasicDuckGetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>
              Fallback handler for missing members.
            </summary>
      <param name="target" />
      <param name="errorSuggestion" />
      <returns />
    </member>
    <member name="T:FlitBit.IoC.BasicDuckSetMemberBinder">
      <summary>
              Helper class for setting duck type'd members.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.BasicDuckSetMemberBinder.#ctor(System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="name" />
    </member>
    <member name="M:FlitBit.IoC.BasicDuckSetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>
              Fallback handler for missing members.
            </summary>
      <param name="target" />
      <param name="value" />
      <param name="errorSuggestion" />
      <returns />
    </member>
    <member name="T:FlitBit.IoC.Duck">
      <summary>
              Utility class for accomplishing limited duck typing.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Duck.TypeAs``1(System.Object)">
      <summary>
              Creates a duck type proxy over a source object.
            </summary>
      <typeparam name="T" />
      <param name="source" />
      <returns />
      <requires csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <requires csharp="typeof(T).IsInterface" vb="typeof(T).IsInterface">typeof(T).IsInterface</requires>
    </member>
    <member name="M:FlitBit.IoC.Duck.ImplementConstructor(FlitBit.Emit.EmittedClass)">
      <summary>
              Overrides the base constructor on the concrete type.
            </summary>
      <param name="type" />
    </member>
    <member name="T:FlitBit.IoC.ScopeBehavior">
      <summary>
              Enumeration of scope behaviors
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ScopeBehavior.Default">
      <summary>
              Default == InstancePerRequest
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ScopeBehavior.InstancePerRequest">
      <summary>
              Indicates an instance is created for each
              container request. (Default)
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ScopeBehavior.SpecializationDisallowed">
      <summary>
              Indicates that specialization is no longer allowed.
              Pertains to the current container as well as any subsequent container scopes.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ScopeBehavior.InstancePerScope">
      <summary>
              Indicates an instance is created for each
              lifetime scope.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ScopeBehavior.Singleton">
      <summary>
              Indicates an instance is only created once
              within the shared-scope of a root container.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ScopeBehavior.LockedSingleton">
      <summary>
              Indicates an instances is a singleton and cannot be overriden
              once defined.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ParamKind">
      <summary>
              Enum of param kinds
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.UserSupplied">
      <summary>
              Indicates user supplied.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.ContainerSupplied">
      <summary>
              Indicates container supplied.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.DeclaredDefault">
      <summary>
              Indicates declared as the default.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.ContainerDefault">
      <summary>
              Indicates container supplied default
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.Named">
      <summary>
              Indicates the param is named
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.DefaultNamed">
      <summary>
              Indicates the param is default, named, and container supplied
            </summary>
    </member>
    <member name="F:FlitBit.IoC.ParamKind.Missing">
      <summary>
              Indicates the param is missing
            </summary>
    </member>
    <member name="T:FlitBit.IoC.CreationContextOptions">
      <summary>
              Options for creation contexts.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationContextOptions.None">
      <summary>
              No options.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationContextOptions.InstanceTracking">
      <summary>
              Indicates the creation context should track instances.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationContextOptions.EnableCaching">
      <summary>
              Indicates that caching is enabled.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationContextOptions.InheritCache">
      <summary>
              Indicates the creation context should inherit cached items from the outer context.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationContextOptions.InheritScope">
      <summary>
              Indicates that the context should inherit its scope from an outer scope if one exists.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.CreationEventKind">
      <summary>
              Kinds of creation events.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationEventKind.Created">
      <summary>
              Indicates the factory created the instance (or caused to be created).
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationEventKind.Initialized">
      <summary>
              Indicates the factory invoked an initializer for the instance.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationEventKind.Copied">
      <summary>
              Indicates the factory copy-constructed an instance based on another instance.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationEventKind.Cached">
      <summary>
              Indicates the factory cached the instance.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationEventKind.Reissued">
      <summary>
              Indicates the factory reissued the instance.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.CreationEventKind.DuckType">
      <summary>
              Indicates the factory ducktyped an instance of another type.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ContainerException">
      <summary>
              Base container exception.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerException.#ctor">
      <summary>
              Default constructor; creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerException.#ctor(System.String)">
      <summary>
              Creates a new instance using the error message given.
            </summary>
      <param name="errorMessage">An error message describing the exception.</param>
    </member>
    <member name="M:FlitBit.IoC.ContainerException.#ctor(System.String,System.Exception)">
      <summary>
              Creates a new instance using the error message and cuase given.
            </summary>
      <param name="errorMessage">An error message describing the exception.</param>
      <param name="cause">An inner exception that caused this exception</param>
    </member>
    <member name="M:FlitBit.IoC.ContainerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Used during serialization.
            </summary>
      <param name="si">SerializationInfo</param>
      <param name="sc">StreamingContext</param>
    </member>
    <member name="T:FlitBit.IoC.ContainerRegistryException">
      <summary>
              Indicates an exception during container registration.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistryException.#ctor">
      <summary>
              Default constructor; creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistryException.#ctor(System.String)">
      <summary>
              Creates a new instance using the error message given.
            </summary>
      <param name="errorMessage">An error message describing the exception.</param>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistryException.#ctor(System.String,System.Exception)">
      <summary>
              Creates a new instance using the error message and cuase given.
            </summary>
      <param name="errorMessage">An error message describing the exception.</param>
      <param name="cause">An inner exception that caused this exception</param>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Used during serialization.
            </summary>
      <param name="si">SerializationInfo</param>
      <param name="sc">StreamingContext</param>
    </member>
    <member name="T:FlitBit.IoC.MissingParameterException">
      <summary>
              Indicates a required parameter was not supplied while resolving a type.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.MissingParameterException.#ctor">
      <summary>
              Default constructor; creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.MissingParameterException.#ctor(System.String)">
      <summary>
              Creates a new instance using the error message given.
            </summary>
      <param name="errorMessage">An error message describing the exception.</param>
    </member>
    <member name="M:FlitBit.IoC.MissingParameterException.#ctor(System.String,System.Exception)">
      <summary>
              Creates a new instance using the error message and cuase given.
            </summary>
      <param name="errorMessage">An error message describing the exception.</param>
      <param name="cause">An inner exception that caused this exception</param>
    </member>
    <member name="M:FlitBit.IoC.MissingParameterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Used during serialization.
            </summary>
      <param name="si">SerializationInfo</param>
      <param name="sc">StreamingContext</param>
    </member>
    <member name="T:FlitBit.IoC.TypeExtensions">
      <summary>
              Various Type extensions.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.TypeExtensions.GetFullName(System.Delegate)">
      <summary>
              Gets the fully qualified, human readable name for a delegate.
            </summary>
      <param name="d" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="d != null" vb="d &lt;&gt; Nothing">d != null</requires>
      <exception cref="T:System.ArgumentNullException">d == null</exception>
    </member>
    <member name="T:FlitBit.IoC.LifespanTracking">
      <summary>
              Indicates how a container should track the lifespan an
              object it creates.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.LifespanTracking.Default">
      <summary>
              Default tracking == Automatic.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.LifespanTracking.Automatic">
      <summary>
              Indicates the container must automatically track the lifespans
              and ensure IDisposable instances are disposed.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.LifespanTracking.External">
      <summary>
              Indicates the instances are externally tracked. Callers are
              responsible for cleaning up IDisposable instances.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ContainerExtensions">
      <summary>
              IContainer extensions.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.AsIf``1(FlitBit.IoC.IContainer,System.Object)">
      <summary>
              Creates an interface proxy type T over the source object. (If it looks like a duck, etc, etc.)
            </summary>
      <typeparam name="T">interface type T</typeparam>
      <param name="c">the container</param>
      <param name="source">the source</param>
      <returns>an interface proxy (duck type) over the source</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
      <requires exception="T:System.ArgumentException" csharp="typeof(T).IsInterface" vb="typeof(T).IsInterface">typeof(T).IsInterface</requires>
      <exception cref="T:System.ArgumentException">!(typeof(T).IsInterface)</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.ForGenericType(FlitBit.IoC.IContainer,System.Type)">
      <summary>
              Gets the type registry for a generic type.
            </summary>
      <param name="c">a container</param>
      <param name="generic">a generic type</param>
      <returns>a registry for the generic type</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="generic != (System.Type)null" vb="generic &lt;&gt; ((System.Type)Nothing) ">generic != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">generic == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.ForType``1(FlitBit.IoC.IContainer)">
      <summary>
              Gets the registry for type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="c">the container</param>
      <returns>the registry for type T</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.MakeChildContainer(FlitBit.IoC.IContainer)">
      <summary>
              Makes a child container from the current container.
            </summary>
      <returns>a child container</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.MakeChildContainer(FlitBit.IoC.IContainer,FlitBit.IoC.CreationContextOptions)">
      <summary>
              Makes a child container from the current container.
            </summary>
      <param name="c">the container</param>
      <param name="options">creation context options</param>
      <returns>a child container</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.Mutate``2(FlitBit.IoC.IContainer,``1,System.Func{FlitBit.IoC.IContainer,``0,``0})">
      <summary>
              Creates a new instance of type T as a mutation of type S, using the provided mutator.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="c">a container</param>
      <param name="source">a source object</param>
      <param name="mutator">a mutator function</param>
      <returns>an instance of type T, initialized from the source object, mutated using the provided mutator.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="mutator != null" vb="mutator &lt;&gt; Nothing">mutator != null</requires>
      <exception cref="T:System.ArgumentNullException">mutator == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.Mutate``2(FlitBit.IoC.IContainer,``1,System.Func{FlitBit.IoC.IContainer,``0,``0},FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T as a mutation of type S, using the provided mutator.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="c">a container</param>
      <param name="source">a source object</param>
      <param name="mutator">a mutator function</param>
      <param name="tracking">lifespan tracking for the new instance</param>
      <returns>an instance of type T, initialized from the source object, mutated using the provided mutator.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="mutator != null" vb="mutator &lt;&gt; Nothing">mutator != null</requires>
      <exception cref="T:System.ArgumentNullException">mutator == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.New``1(FlitBit.IoC.IContainer)">
      <summary>
              Resolves type T to an instance according to it's registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>an instance of type T</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewCopy``2(FlitBit.IoC.IContainer,``1)">
      <summary>
              Creates a new instance of type T, initialized from the provided source.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="c">a container</param>
      <param name="source">a source object</param>
      <returns>an instance of type T, initialized from the source object.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewCopy``2(FlitBit.IoC.IContainer,``1,FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T, initialized from the provided source.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <typeparam name="TSource">source type S</typeparam>
      <param name="c">a container</param>
      <param name="source">a source object</param>
      <param name="tracking">tracking</param>
      <returns>an instance of type T, initialized from the source object.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewImplementationOf``1(FlitBit.IoC.IContainer,System.Type)">
      <summary>
              Resolves a specific implementation of type T according to the implementation's registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="c">a container</param>
      <param name="implementationType">the implementation type</param>
      <returns>an instance of the implementation type</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewImplementationOf``2(FlitBit.IoC.IContainer,FlitBit.IoC.LifespanTracking)">
      <summary>
              Resolves a specific implementation of type T according to the implementation's registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <typeparam name="TConcrete">implementetion type C</typeparam>
      <param name="c">a container</param>
      <param name="tracking">
              Lifespan tracking used for the instance
              if it is newly created.
            </param>
      <returns>an instance of the implementation type</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewInit``1(FlitBit.IoC.IContainer)">
      <summary>
              Creates a new instance of type T for initialization.
            </summary>
      <typeparam name="T" />
      <param name="c" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewInit``1(FlitBit.IoC.IContainer,FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T for initialization.
            </summary>
      <typeparam name="T" />
      <param name="c" />
      <param name="tracking" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewInit``1(FlitBit.IoC.IContainer,System.Func{FlitBit.IoC.IContainer,``0,``0})">
      <summary>
              Creates a new instance of type T and initializes it using the provided initializer.
            </summary>
      <typeparam name="T" />
      <param name="c" />
      <param name="initializer" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="initializer != null" vb="initializer &lt;&gt; Nothing">initializer != null</requires>
      <exception cref="T:System.ArgumentNullException">initializer == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewInit``1(FlitBit.IoC.IContainer,System.Func{FlitBit.IoC.IContainer,``0,``0},FlitBit.IoC.LifespanTracking)">
      <summary>
              Creates a new instance of type T and initializes it using the provided initializer.
            </summary>
      <typeparam name="T" />
      <param name="c" />
      <param name="initializer" />
      <param name="tracking" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="initializer != null" vb="initializer &lt;&gt; Nothing">initializer != null</requires>
      <exception cref="T:System.ArgumentNullException">initializer == null</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewNamed``1(FlitBit.IoC.IContainer,System.String)">
      <summary>
              Resolves type T to an instance according to a named registration.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="c">a container</param>
      <param name="name">the name</param>
      <returns>an instance of type T</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires description="name cannot be null" exception="T:System.ArgumentNullException" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <exception cref="T:System.ArgumentNullException">name == null</exception>
      <requires description="name cannot be empty" exception="T:System.ArgumentNullException" csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentNullException">name.Length &lt;= 0</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewNamedWithParams``1(FlitBit.IoC.IContainer,System.String,FlitBit.IoC.Param[])">
      <summary>
              Resolves type T to an instance according to a named registration, utilizing the
              parameters given if the instance must be newly created.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="c">a container</param>
      <param name="name">the name</param>
      <param name="parameters">
              Initialization parameters whose values are used
              if an instance must be newly created.
            </param>
      <returns>an instance of type T</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires description="name cannot be null" exception="T:System.ArgumentNullException" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <exception cref="T:System.ArgumentNullException">name == null</exception>
      <requires description="name cannot be empty" exception="T:System.ArgumentNullException" csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentNullException">name.Length &lt;= 0</exception>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewUntyped(FlitBit.IoC.IContainer,System.Type)">
      <summary>
              Resolves an instance according to a target type's registration.
            </summary>
      <returns>an instance</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="targetType != (System.Type)null" vb="targetType &lt;&gt; ((System.Type)Nothing) ">targetType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">targetType == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.ContainerExtensions.NewWithParams``1(FlitBit.IoC.IContainer,FlitBit.IoC.Param[])">
      <summary>
              Resolves type T to an instance according to it's registration, utilizing the
              parameters given if the instance must be newly created.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="c">a container</param>
      <param name="parameters">
              Initialization parameters whose values are used
              if an instance must be newly created.
            </param>
      <returns>an instance of type T</returns>
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="T:FlitBit.IoC.IContainerOwned">
      <summary>
              Interface for objects owned by a container.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.IContainerOwned.Container">
      <summary>
              Gets the container owner.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ContainerOwned">
      <summary>
              abstract implementation of the IContainerOwned interface
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerOwned.#ctor(FlitBit.IoC.IContainer)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="container">the container, owner</param>
      <requires exception="T:System.ArgumentNullException" csharp="container != null" vb="container &lt;&gt; Nothing">container != null</requires>
      <exception cref="T:System.ArgumentNullException">container == null</exception>
    </member>
    <member name="P:FlitBit.IoC.ContainerOwned.Container">
      <summary>
              Returns the container, owner.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.IContainerRegistrationParticipant">
      <summary>
              Interface for registration participants.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistrationParticipant.End">
      <summary>
              Ends registration for the participant and returns the
              owning container.
            </summary>
      <returns>The owner, container.</returns>
    </member>
    <member name="P:FlitBit.IoC.IContainerRegistrationParticipant.IsEnded">
      <summary>
              Indicates whether the registration has ended for this participant.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ContainerRegistrationParticipant">
      <summary>
              Abstract implementation of IContainerRegistrationParticipant
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistrationParticipant.#ctor(FlitBit.IoC.IContainer)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="container">the container where the registration is occurring</param>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistrationParticipant.OnEnded">
      <summary>
              Method called when registration is ended.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ContainerRegistrationParticipant.End">
      <summary>
              Ends registration for the participant and returns the
              owning container.
            </summary>
      <returns>The owner, container.</returns>
    </member>
    <member name="P:FlitBit.IoC.ContainerRegistrationParticipant.IsEnded">
      <summary>
              Indicates whether the registration has ended for this participant.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.IContainerRegistry">
      <summary>
              A container registry is used to register types and resolve those registrations.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.ForGenericType(System.Type)">
      <summary>
              Gets the registry for a generic type.
            </summary>
      <param name="generic">the generic type</param>
      <returns>the registry for the generic type</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.ForType``1">
      <summary>
              Gets the registry specific to type T
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>the type registry</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.UntypedRegistryFor(System.Type)">
      <summary>
            Gets the registry specific to the <paramref name="type" /> provided.
            </summary>
      <param name="type" />
      <returns />
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.IsTypeRegistered``1">
      <summary>
              Determines if type T is registered.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>true if type T is registered; otherwise false</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.IsTypeRegistered(System.Type)">
      <summary>
              Determins if a type is registered.
            </summary>
      <param name="type">the type</param>
      <returns>true if the type is registered; otherwise false</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.TryGetNamedResolverForType``1(System.String,FlitBit.IoC.IResolver{``0}@)">
      <summary>
              Tries to get a named resolver for type T
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="name">the name</param>
      <param name="value">variable to hold the resolver upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.TryGetResolverForType(System.Type,FlitBit.IoC.IResolver@)">
      <summary>
              Tries to get the resolver for a type.
            </summary>
      <param name="type">the type</param>
      <param name="value">variable to hold the resolver upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.TryGetResolverForType``1(FlitBit.IoC.IResolver{``0}@)">
      <summary>
              Tries to get the resolver for type T
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="value">variable to hold the resolver upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="M:FlitBit.IoC.IContainerRegistry.TryGetTypeRegistryManagement(System.Type,FlitBit.IoC.ITypeRegistryManagement@)">
      <summary>
              Tries to get the type registry management object for a type.
            </summary>
      <param name="type">the type</param>
      <param name="value">variable to hold the result upon success</param>
      <returns>true if successful; otherwise false</returns>
    </member>
    <member name="T:FlitBit.IoC.IGenericTypeRegistry">
      <summary>
              Type registry for generics.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ITypeRegistry">
      <summary>
              Root, untyped interface for type registry.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry.Register(System.Type,FlitBit.IoC.Param[])">
      <summary>
              Registers the concrete type.
            </summary>
      <param name="concreteType">
              A concrete type to be issued by
              the container when instances of the registered type are resolved.
            </param>
      <param name="parameters">pre-set parameters</param>
      <returns>
              The concrete registration (can be used to specialize the
              registration).
            </returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry.RegisterUntypedFactory(System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],System.Object})">
      <summary>
            Registers a factory returning an untyped instance of the registered type.
            </summary>
      <param name="factory" />
      <returns />
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistry.CanSpecializeRegistration">
      <summary>
              Indicates whether the registration can be specialized or
              overridden by subsequent registrations.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistry.RegisteredType">
      <summary>
              Gets the registered type.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistry.UntypedResolver">
      <summary>
              Gets the type's untyped resolver.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.IGenericTypeRegistry.ResolverFor``1">
      <summary>
              Gets a resolver for generic type T
            </summary>
      <typeparam name="T">generic type T</typeparam>
      <returns>gets the type's resolver</returns>
    </member>
    <member name="T:FlitBit.IoC.INamedRegistration">
      <summary>
              Interface for named registrations.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.INamedRegistration.Name">
      <summary>
              Gets the registration's name.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Initialize`1">
      <summary>
              Intermediate class used by the framework to capture
              a newly created object and initialize it from data provided
              by another object.
            </summary>
      <typeparam name="T">object type T</typeparam>
    </member>
    <member name="M:FlitBit.IoC.Initialize`1.#ctor(FlitBit.IoC.IContainer,`0)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="c" />
      <param name="it" />
      <requires exception="T:System.ArgumentNullException" csharp="c != null" vb="c &lt;&gt; Nothing">c != null</requires>
      <exception cref="T:System.ArgumentNullException">c == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Initialize`1.Init``1(``0)">
      <summary>
              Initializes the newly created instance from values given.
            </summary>
      <typeparam name="TInit" />
      <param name="init" />
      <returns />
    </member>
    <member name="P:FlitBit.IoC.Initialize`1.Instance">
      <summary>
              The newly created instance.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.IResolver">
      <summary>
              Interface for resolvers.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.IResolver.TryUntypedResolve(FlitBit.IoC.IContainer,FlitBit.IoC.LifespanTracking,System.String,System.Object@,FlitBit.IoC.Param[])">
      <summary>
              Tries to resolve an instance of the type according to its registration.
            </summary>
      <param name="container">the container</param>
      <param name="tracking">lifespan tracking</param>
      <param name="name">registered name or null</param>
      <param name="instance">variable where the instance will be returned upon success</param>
      <param name="parameters">one or more params to be used in resolving the instance</param>
      <returns>true if an instance is resolved; otherwise false</returns>
    </member>
    <member name="P:FlitBit.IoC.IResolver.TargetType">
      <summary>
              Gets the type used by the resolver to fullfil resolve requests.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.IResolver`1">
      <summary>
              Interface for resolvers of target type T
            </summary>
      <typeparam name="T">target type T</typeparam>
    </member>
    <member name="M:FlitBit.IoC.IResolver`1.TryResolve(FlitBit.IoC.IContainer,FlitBit.IoC.LifespanTracking,System.String,`0@,FlitBit.IoC.Param[])">
      <summary>
              Tries to resolve an instance of the type according to its registration.
            </summary>
      <param name="container">the container</param>
      <param name="tracking">lifespan tracking</param>
      <param name="name">registered name or null</param>
      <param name="instance">variable where the instance will be returned upon success</param>
      <param name="parameters">one or more params to be used in resolving the instance</param>
      <returns>true if an instance is resolved; otherwise false</returns>
    </member>
    <member name="T:FlitBit.IoC.ITenantResolver">
      <summary>
              Interface for tenant resolvers
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ITenantResolver.TryResolveTenant(System.Object@)">
      <summary>
              Tries to resolve the current tenant ID.
            </summary>
      <param name="tenantID">variable to hold the tenant id</param>
      <returns>true if a tenant ID is resolved; otherwise false</returns>
    </member>
    <member name="T:FlitBit.IoC.ITypeRegistration">
      <summary>
              Registration for a type.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistration.DisallowSpecialization">
      <summary>
              Indicates that a type hsould be resolved per request.
            </summary>
      <returns>the registration (for chaining)</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistration.ResolveAnInstancePerRequest">
      <summary>
              Indicates that a type hsould be resolved per request.
            </summary>
      <returns>the registration (for chaining)</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistration.ResolveAnInstancePerScope">
      <summary>
              Indicates that a type hsould be resolved per request.
            </summary>
      <returns>the registration (for chaining)</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistration.ResolveAsSingleton">
      <summary>
              Indicates that a type hsould be resolved per request.
            </summary>
      <returns>the registration (for chaining)</returns>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistration.IsNamed">
      <summary>
              Indicates whether the registration is named.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistration.RegisteredType">
      <summary>
              The registered type.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistration.ScopeBehavior">
      <summary>
              Gets the registration's scope behavior.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistration.TargetType">
      <summary>
              The target type.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistration.UntypedResolver">
      <summary>
              Gets the registered type's untyped resolver.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.INamedTypeRegistration">
      <summary>
              Interface for named type registrations.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ITypeRegistration`1">
      <summary>
              Type registration for type T
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistration`1.Resolver">
      <summary>
              Gets the resolver for type T.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.INamedTypeRegistration`1">
      <summary>
              Named type registration for type T.
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="T:FlitBit.IoC.ITypeRegistry`1">
      <summary>
              Type registry for type T
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry`1.LazyRegister(System.Func{System.Type,System.Type})">
      <summary>
              Registers a function that will provide an implementation of type T upon demand.
            </summary>
      <param name="producer">
              a callback function that will produce the
              implementation type upon demand
            </param>
      <returns>the resulting type registration</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry`1.Register``1(FlitBit.IoC.Param[])">
      <summary>
              Registers an implementation for resolving instances of type T.
            </summary>
      <typeparam name="TConcrete">implementation type TConcrete</typeparam>
      <param name="parameters">one or more Params to be used when resolving instances of type T</param>
      <returns>the registration for chaining calls</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry`1.Register``1(System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],``0})">
      <summary>
              Registers a factory for use when resolving instances of type T.
            </summary>
      <typeparam name="TConcrete">implementation type TConcrete</typeparam>
      <param name="factory">a factory providing instances of the implementation type</param>
      <returns>the registration for chaining calls</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry`1.RegisterWithName``1(System.String,FlitBit.IoC.Param[])">
      <summary>
              Registers an implementation for resolving instances of type T by name.
            </summary>
      <typeparam name="TConcrete">implementation type TConcrete</typeparam>
      <param name="name">the name</param>
      <param name="parameters">pre-set parameters to use when resolving instances.</param>
      <returns>the registration for chaining calls</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry`1.RegisterWithName``1(System.String,System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],``0})">
      <summary>
              Registers a named factory registration for resolving instances of type T by name.
            </summary>
      <typeparam name="TConcrete">implementation type TConcrete</typeparam>
      <param name="name">the name</param>
      <param name="factory">a factory providing instances of type C</param>
      <returns>the registration for chaining calls</returns>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistry`1.TryGetNamedResolver(System.String,FlitBit.IoC.IResolver{`0}@)">
      <summary>
              Gets the named type resolver for type T. Intended for framework use; you should never need this.
            </summary>
      <param name="name">the type's name</param>
      <param name="value">variable that will hold the resolver upon success</param>
      <returns>true if successful; otherwise false.</returns>
    </member>
    <member name="P:FlitBit.IoC.ITypeRegistry`1.Resolver">
      <summary>
              Gets the type resolver for type T. Intended for framework use; you should never need this.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.ITypeRegistryManagement">
      <summary>
              Interface for managing type registries.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ITypeRegistryManagement.MakeCopyForContainer(FlitBit.IoC.IContainer)">
      <summary>
              Makes a copy of a type registry for the target container.
            </summary>
      <param name="container">a target container</param>
      <returns>a copy of the type registry</returns>
    </member>
    <member name="T:FlitBit.IoC.ModuleWireupTask">
      <summary>
              Wires this module.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ModuleWireupTask.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ModuleWireupTask.PerformTask(FlitBit.Wireup.IWireupCoordinator)">
      <summary>
              Performs wireup.
            </summary>
      <param name="coordinator" />
    </member>
    <member name="T:FlitBit.IoC.ParamExtensions">
      <summary>
              extensions for the Param class
            </summary>
    </member>
    <member name="M:FlitBit.IoC.ParamExtensions.AssignableTo``1(FlitBit.IoC.Param[],FlitBit.IoC.IContainer)">
      <summary>
              Gets a value from the first parameter assignable to type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="pp">array of parameters</param>
      <param name="c">a container</param>
      <returns>the parameter's value</returns>
    </member>
    <member name="M:FlitBit.IoC.ParamExtensions.At``1(FlitBit.IoC.Param[],System.Int32,FlitBit.IoC.IContainer)">
      <summary>
              Gets a value from the parameter of type T and at the index given.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="pp">array of paramters</param>
      <param name="position">the parameter's index</param>
      <param name="c">a container</param>
      <returns>the parameter's value</returns>
    </member>
    <member name="M:FlitBit.IoC.ParamExtensions.First(FlitBit.IoC.Param[],System.Func{FlitBit.IoC.Param,System.Boolean})">
      <summary>
              Gets the first parameter from <paramref name="pp" /> that satisfies the predticate.
            </summary>
      <param name="pp">array of paramters</param>
      <param name="predicate">the predicate</param>
      <returns>the first param succeeding the predicate</returns>
    </member>
    <member name="M:FlitBit.IoC.ParamExtensions.Named``1(FlitBit.IoC.Param[],System.String,FlitBit.IoC.IContainer)">
      <summary>
              Gets a value from the first parameter assignable to T and with the name given.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="pp">array of parameters</param>
      <param name="name">the parameter's name</param>
      <param name="container">a container</param>
      <returns>the parameter's value</returns>
    </member>
    <member name="M:FlitBit.IoC.ParamExtensions.OfType``1(FlitBit.IoC.Param[],FlitBit.IoC.IContainer)">
      <summary>
              Gets a value from the first parameter of type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="pp">array of parameters</param>
      <param name="container">a container</param>
      <returns>the parameter's value</returns>
    </member>
    <member name="T:FlitBit.IoC.Param">
      <summary>
              Abstract class for parameters used with a container.
            </summary>
    </member>
    <member name="F:FlitBit.IoC.Param.EmptyParams">
      <summary>
              An empty param array.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Param.#ctor(FlitBit.IoC.ParamKind,System.Type)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="kind" />
      <param name="typeofValue" />
    </member>
    <member name="M:FlitBit.IoC.Param.GetValue(FlitBit.IoC.IContainer)">
      <summary>
              Gets the parameter's value.
            </summary>
      <param name="container">scoping container</param>
      <returns>the param's value</returns>
    </member>
    <member name="M:FlitBit.IoC.Param.Named``1(System.String,``0)">
      <summary>
              Creates a param with a name and value.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="name">the name</param>
      <param name="value">the value</param>
      <returns>a param</returns>
    </member>
    <member name="M:FlitBit.IoC.Param.Resolve``1">
      <summary>
              Creates a param that will resolve type T from the container.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>a param</returns>
    </member>
    <member name="M:FlitBit.IoC.Param.ResolveNamed``1(System.String)">
      <summary>
              Creates a param that will resolve type T from the container by registered name.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="name">the registered name</param>
      <returns>a param</returns>
    </member>
    <member name="M:FlitBit.IoC.Param.FromValue``1(``0)">
      <summary>
              Creates a param on a value.
            </summary>
      <typeparam name="T">value type T</typeparam>
      <param name="value">the value</param>
      <returns>a param</returns>
    </member>
    <member name="P:FlitBit.IoC.Param.HasName">
      <summary>
              Indicates whether the param is named.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Param.Kind">
      <summary>
              Gets the param's kind.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Param.Name">
      <summary>
              Gets the param's name.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Param.TypeofValue">
      <summary>
              Gets the type of the param's value.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Properties.Resources.Chk_TypeMustBeAssignableToTypeofT">
      <summary>
              Looks up a localized string similar to type must be assignable to the generic type argument used during invocation.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Properties.Resources.Chk_TypeofTIsInterface">
      <summary>
              Looks up a localized string similar to typeof(T) must be an interface.
            </summary>
    </member>
    <member name="P:FlitBit.IoC.Properties.Resources.Err_StereotypeBehaviorGeneratedForInterfacesOnly">
      <summary>
              Looks up a localized string similar to this stereotypical behavior can only be generated for interfaces.
            </summary>
    </member>
    <member name="T:FlitBit.IoC.Registry.IGenericTypeRegistration">
      <summary>
              Registration for a generic type.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.Registry.IGenericTypeRegistration.ResolverFor``1">
      <summary>
              Gets a resolver for type T
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>the resolver for type T</returns>
    </member>
    <member name="T:FlitBit.IoC.WireupThisAssembly">
      <summary>
              Wires up this assembly.
            </summary>
    </member>
    <member name="M:FlitBit.IoC.WireupThisAssembly.Execute(FlitBit.Wireup.IWireupCoordinator)">
      <summary>
              Wires up this assembly.
            </summary>
      <param name="coordinator" />
    </member>
    <member name="M:FlitBit.IoC.Containers.RootContainer.RegisterTenant(System.Object)">
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.IoC.Param.MakeValueUsingReflection(FlitBit.IoC.ParamKind,System.Type,System.Object)">
      <requires exception="T:System.ArgumentException" csharp="typeof(FlitBit.IoC.ParamValue&lt;&gt;).GetGenericArguments().Length == 1" vb="typeof(FlitBit.IoC.ParamValue).GetGenericArguments().Length = 1">typeof(FlitBit.IoC.ParamValue&lt;&gt;).GetGenericArguments().Length == 1</requires>
      <exception cref="T:System.ArgumentException">!(typeof(ParamValue&lt;&gt;).GetGenericArguments().Length == 1)</exception>
    </member>
    <member name="M:FlitBit.IoC.Param.TryBindSuppliedDefaults(System.Reflection.ConstructorInfo,FlitBit.IoC.Param[],FlitBit.IoC.Param[]@)">
      <requires exception="T:System.ArgumentNullException" csharp="ci != (System.Reflection.ConstructorInfo)null" vb="ci &lt;&gt; ((System.Reflection.ConstructorInfo)Nothing) ">ci != (System.Reflection.ConstructorInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">ci == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Meta.ContainerRegisterAttribute.ApplyRegistrationFor``2(FlitBit.IoC.IContainer)">
      <requires exception="T:System.ArgumentNullException" csharp="container != null" vb="container &lt;&gt; Nothing">container != null</requires>
      <exception cref="T:System.ArgumentNullException">container == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Constructors.CommandBinding`1.Create(FlitBit.IoC.Constructors.ConstructorAdapter{`0},FlitBit.IoC.Param[])">
      <requires exception="T:System.ArgumentNullException" csharp="parameters != null" vb="parameters &lt;&gt; Nothing">parameters != null</requires>
      <exception cref="T:System.ArgumentNullException">parameters == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.UntypedFactoryTypeRegistration`1.#ctor(FlitBit.IoC.IContainer,System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],System.Object})">
      <requires exception="T:System.ArgumentNullException" csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
      <exception cref="T:System.ArgumentNullException">factory == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.NamedTypeRegistration`2.#ctor(FlitBit.IoC.IContainer,System.String,FlitBit.IoC.Param[])">
      <requires exception="T:System.ArgumentNullException" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <exception cref="T:System.ArgumentNullException">name == null</exception>
      <requires exception="T:System.ArgumentException" csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">name.Length &lt;= 0</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.TypeRegistration.#ctor(FlitBit.IoC.IContainer,System.Type)">
      <requires exception="T:System.ArgumentNullException" csharp="registeredType != (System.Type)null" vb="registeredType &lt;&gt; ((System.Type)Nothing) ">registeredType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">registeredType == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.FactoryTypeRegistration`2.#ctor(FlitBit.IoC.IContainer,System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],`1})">
      <requires exception="T:System.ArgumentNullException" csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
      <exception cref="T:System.ArgumentNullException">factory == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.LazyTypeRegistration`1.#ctor(FlitBit.IoC.IContainer,System.Func{System.Type,System.Type},FlitBit.IoC.Param[])">
      <requires exception="T:System.ArgumentNullException" csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
      <exception cref="T:System.ArgumentNullException">factory == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.NamedFactoryTypeRegistration`2.#ctor(FlitBit.IoC.IContainer,System.String,System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],`1})">
      <requires exception="T:System.ArgumentNullException" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <exception cref="T:System.ArgumentNullException">name == null</exception>
      <requires exception="T:System.ArgumentException" csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">name.Length &lt;= 0</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.FactorySingletonResolver`1.#ctor(FlitBit.IoC.IContainer,System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],System.Object})">
      <requires exception="T:System.ArgumentNullException" csharp="owner != null" vb="owner &lt;&gt; Nothing">owner != null</requires>
      <exception cref="T:System.ArgumentNullException">owner == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.FactorySingletonResolver`2.#ctor(FlitBit.IoC.IContainer,System.Func{FlitBit.IoC.IContainer,FlitBit.IoC.Param[],`1})">
      <requires exception="T:System.ArgumentNullException" csharp="owner != null" vb="owner &lt;&gt; Nothing">owner != null</requires>
      <exception cref="T:System.ArgumentNullException">owner == null</exception>
    </member>
    <member name="M:FlitBit.IoC.Registry.SingletonResolver`2.#ctor(FlitBit.IoC.IContainer,FlitBit.IoC.Constructors.ConstructorSet{`0,`1})">
      <requires exception="T:System.ArgumentNullException" csharp="owner != null" vb="owner &lt;&gt; Nothing">owner != null</requires>
      <exception cref="T:System.ArgumentNullException">owner == null</exception>
    </member>
  </members>
</doc>